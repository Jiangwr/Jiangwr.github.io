<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Java多线程基础 | 编程学习记录</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java多线程基础</h1><a id="logo" href="/.">编程学习记录</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java多线程基础</h1><div class="post-meta">Jul 21, 2018<span> | </span><span class="category"><a href="/categories/Java/">Java</a></span></div><div class="post-content"><p>记录一些需要知道的 Java 多线程相关知识。</p>
<a id="more"></a>
<h2 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h2><ol>
<li>实现Runnable接口</li>
<li>实现Callable接口</li>
<li>继承Thread类</li>
</ol>
<p>实现Runnable和Callable接口的类只能当作一个可以在线程中运行的任务，不是真正意义上的线程，因为最后还是需要通过Thread类来调用，可以说任务是通过线程驱动而执行的。</p>
<p>实现Runnable接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"运行中！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyRunnable myRunnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现Callable接口</p>
<p>与Runnable相比，Callable可以有返回值，返回值通过FutureTasK封装。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        MyCallable myCallable = <span class="keyword">new</span> MyCallable();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(myCallable);</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承Thread类</p>
<p>因为Thread类也实现了Runnable接口，因此同样需要实现run()方法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void run()&#123;</span><br><span class="line">     <span class="type">System</span>.out.println(<span class="string">"Hello world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(<span class="type">String</span>[] args)&#123;</span><br><span class="line">        <span class="type">MyThread</span> myThread = <span class="keyword">new</span> <span class="type">MyThread</span>();</span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现接口的方式与继承Thread比较</p>
<p>实现接口可能更好一些：1.Java不支持多继承2.类可能只要求可以执行就好了，继承整个类开销过大。</p>
<h2 id="sleep-、join-、yield-的区别"><a href="#sleep-、join-、yield-的区别" class="headerlink" title="sleep()、join()、yield()的区别"></a>sleep()、join()、yield()的区别</h2><p><strong>Thread.sleep()</strong>方法会休眠当前正在执行的线程，休眠时间单位为毫秒。sleep()可能抛出InterruptedException异常，因为异常不能跨线程传播，因此须在本地处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySleep</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(System.currentTimeMillis());</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            System.out.println(System.currentTimeMillis());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MySleep mySleep = <span class="keyword">new</span> MySleep();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(mySleep);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>yield方法</strong></p>
<p>调用静态方法yield()说明当前线程已经完成了生命周期中最重要的部分，可以切换给其他线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其他线程可以运行。</p>
<p><strong>join方法</strong></p>
<p>join 方法底层调用的是 wait 方法，如下</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="comment">(isAlive()</span>) &#123;</span><br><span class="line">    wait<span class="comment">(0)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当目标线程为 terminates 状态时，目标线程会调用 notifyAll() 唤醒调用了 join() 方法的线程。</p>
<h2 id="CountDownLatch与CyclicBarrier"><a href="#CountDownLatch与CyclicBarrier" class="headerlink" title="CountDownLatch与CyclicBarrier"></a>CountDownLatch与CyclicBarrier</h2><p><strong>CountDownLatch</strong></p>
<p>用来控制一个线程等待多个线程。</p>
<p>原理:维护一个计数器，每次调用countDown()方法会让计数器的值减1，减到0的时候，那些因为调用await()方法而等待的线程会被唤醒。</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyCountDownLatch</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    public static <span class="literal">void</span> main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        final int totalThread = <span class="number">10</span>;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (int i=<span class="number">0</span>;i&lt;totalThread;i++)&#123;</span><br><span class="line">            executorService.execute<span class="function"><span class="params">(()-&gt;&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                System.out.println(<span class="string">"Hello "</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">                countDownLatch.countDown();</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125;)</span>;</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">        <span class="title">countDownLatch</span>.<span class="title">await</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">        <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(<span class="string">"World"</span>)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">executorService</span>.<span class="title">shutdown</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>CyclicBarrier</strong></p>
<p>用来控制多线程互相等待，只有这些线程都等待时，这些线程才会继续执行。</p>
<p>原理:维护一个计数器，线程执行await()方法之后，计数器减1并等待，直到计数器为0，所有调用await()方法的线程才能继续执行。</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyCyclicBarrier</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    public static <span class="literal">void</span> main(String[] args)&#123;</span><br><span class="line">        final int totalThread = <span class="number">10</span>;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (int i=<span class="number">0</span>;i&lt;totalThread;i++)&#123;</span><br><span class="line">            executorService.execute<span class="function"><span class="params">(()-&gt;&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                System.out.println(<span class="string">"Hello"</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">try</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                    cyclicBarrier.await();</span></span></span><br><span class="line"><span class="function"><span class="params">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                    e.printStackTrace();</span></span></span><br><span class="line"><span class="function"><span class="params">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                    e.printStackTrace();</span></span></span><br><span class="line"><span class="function"><span class="params">                &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">                System.out.println(<span class="string">"World"</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125;)</span>;</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">        <span class="title">executorService</span>.<span class="title">shutdown</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>CyclicBarrier与CountDownLatch的一个区别是，CyclicBarrier的计数器可以通过调用<code>cyclicBarrier.reset()</code>方法循环使用，所以又被称为循环屏障。</p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MySemaphore</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    public static <span class="literal">void</span> main(String[] args)&#123;</span><br><span class="line">        final int clientCount = <span class="number">3</span>;</span><br><span class="line">        final int totalRequstCount = <span class="number">10</span>;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(clientCount);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (int i=<span class="number">0</span>;i&lt;totalRequstCount;i++)&#123;</span><br><span class="line">            executorService.execute<span class="function"><span class="params">(()-&gt;&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">try</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                    semaphore.acquire();</span></span></span><br><span class="line"><span class="function"><span class="params">                    System.out.println(semaphore.availablePermits());</span></span></span><br><span class="line"><span class="function"><span class="params">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                    e.printStackTrace();</span></span></span><br><span class="line"><span class="function"><span class="params">                &#125;<span class="keyword">finally</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                    semaphore.release();</span></span></span><br><span class="line"><span class="function"><span class="params">                &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125;)</span>;</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">        <span class="title">executorService</span>.<span class="title">shutdown</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                          <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                          <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler <span class="keyword">handler</span>)</span><br></pre></td></tr></table></figure>
<p>ThreadPoolExecutor的7个核心参数:</p>
<ol>
<li>corePoolSize:核心线程池大小。在创建线程之后，默认情况下，线程池没有任何线程，而是等待任务到来才创建线程区执行任务。</li>
<li>maximumPoolSize:线程池允许的最大线程数。当任务数比corePoolSize大时，任务添加到workQueue中，当workQueue满了，将继续创建线程以处理任务。</li>
<li>keepAliveTime:只有当线程池中的线程数量大于核心线程数时，这个参数才会起作用，多余的空闲线程等待任务的最长时间。</li>
<li>unit: keepAliveTime的时间单位</li>
<li>workQueue:存储没来得及执行的任务</li>
<li>threadFactory:执行程序创建线程时使用的工厂</li>
<li>handler:因为超出线程池容量范围和队列容量而执行的处理程序</li>
</ol>
<h2 id="Exector"><a href="#Exector" class="headerlink" title="Exector"></a>Exector</h2><p>Exector管理多个异步任务的执行，而无需开发人员显式地管理线程的生命周期。这里的异步指多个任务执行互不干扰，不需要同步操作。</p>
<ol>
<li>CachedThreadPool:一个任务创建一个线程</li>
<li>FixedThreadPool:所有任务只能使用固定大小的线程</li>
<li>SingleThreadExecutor:相当于大小为1的FixedThreadPool</li>
</ol>
<p><em>拓展</em></p>
<p><strong>阿里编码规范插件给出的建议</strong>:线程池不允许使用Exectors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p>
<p>说明:Exectors各个方法的弊端:</p>
<ul>
<li>newFixedThreadPool和newSingleThreadExecutor:主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。</li>
<li>newCachedThreadPool和newScheduledThreadPool:主要问题是最大线程数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2></li>
</ul>
<p>通俗来讲，线程对于一个volatile变量的修改，对于其他线程是可见的。即线程每次获取的volatile变量的值都是最新的。</p>
<p>汇编代码层面用Lock前缀指令</p>
<ol>
<li>将当前cpu缓存行的数据写回主内存中。</li>
<li>这个写回主内存的操作会导致其他CPU缓存里该内存地址的数据失效。</li>
</ol>
<p>volatile的可见性与禁止重排序是基于内存屏障(Memory Barrier)实现的。内存屏障又称为内存栅栏，是一个CPU指令。在程序运行时，为了提高执行性能，编译器和处理器会对指令进行，插入一条内存屏障会告诉编译器和CPU，不管什么指令都不能和这条内存屏障重排序。</p>
<h2 id="synchronized与lock"><a href="#synchronized与lock" class="headerlink" title="synchronized与lock"></a>synchronized与lock</h2><p>用法比较: </p>
<ol>
<li>lock使用比较灵活，但必须手动获取和释放锁。</li>
<li>lock只适用于代码块，synchronized可用于方法和代码块。</li>
<li>lock可以控制公平性。</li>
<li>lock可以中断地获取锁，中断异常将被抛出，锁会被释放。</li>
</ol>
<p><strong>ReetrantLock</strong>是Lock的实现类，是一个互斥的同步器，在多线程高竞争的条件下，ReetrantLock比synchronized有更加优异的性能表现。</p>
<p>ReetrantLock主要利用CAS+CLH队列(带头节点的双向非循环队列)实现，它支持公平锁和非公平锁。</p>
<p>基本实现:先通过CAS获取锁，如果此时已经有线程占据了锁，那就加入CLH队列并挂起。当锁被释放后，排在CLH队首的线程会被唤醒，然后通过CAS再次获取锁。</p>
<p>如果此时是公平锁:并且同时还有另一线程进来尝试获取锁，当它发现自己不是队首时，会排到队尾，由队首线程获取到锁。</p>
<p>如果此时是非公平锁:并且同时还有另一线程进来获取锁，那么有可能让这个线程先获取。</p>
<p><strong>synchronized</strong></p>
<p>synchronized代码块是由一对monitorenter/monitorexit指令实现的。</p>
<p>类型上可以分为偏斜锁、轻量级锁、重量级锁</p>
<p>当没有竞争，默认使用偏斜锁，JVM利用CAS操作在对象头上的Mark Word部分设置线程Id，如果有另外的线程试图锁定某个被偏斜过的对象，则升级成轻量级锁，轻量级锁依赖CAS操作Mark Word来获取锁，如果成功，就使用轻量级锁，否则，进一步升级成为重量级锁。</p>
<p><em>拓展</em><br> <strong>自旋锁</strong>:竞争锁失败的线程，并不会真实的在操作系统层面挂起等待，而是让JVM做几个空循环，在经过若干循环之后，如果可以获取锁，那么进入临界区，如果还不能获取锁，才会将线程挂起。<br><strong>重入</strong>:由于内置锁是可重入的，因此如果某个线程试图获得一个已经由他自己持有的锁，那么这个请求就会成功。”重入”意味着获取锁的操作的粒度是”线程”，而不是调用。重入的实现方式是，为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置为1。如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数值会相应递减。当计数值为0时，这个锁将被释放。(内置锁:每个Java对象都可以用做一个实现同部的锁，这些锁被称为内置锁(Intrinsic Lock)或者监视器(Monitor Lock)–《Java并发编程实战》)</p>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS是非阻塞同步的。</p>
<p>CAS指令需要三个操作数，分别是内存地址V，旧的预期值A和新值B。当执行操作时，只有当V的值等于A,才将V的值更新为B。</p>
<p><strong>ABA问题</strong></p>
<p>如果一个变量初次读取的时候是A值，它的值被改成了B，后来又被改回A,那CAS操作会误认为它从来没有被改变过。通过原子引用类AtomicStampedReference来控制变量值的版本来解决这个问题。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>极客时间 杨晓峰的Java专栏</li>
<li>《Java并发编程实战》</li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98" target="_blank" rel="noopener">CyC2018/CS-Notes</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/22820761" target="_blank" rel="noopener">美团技术团队-分布式系统互斥性与幂等性问题的分析与解决</a></li>
</ol>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2018/08/02/计算机网络基础/">计算机网络基础</a><a class="next" href="/2018/07/13/面试常见的String问题/">面试常见的String问题</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Scala/">Scala</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web技术/">Web技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/书籍阅读/">书籍阅读</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发经验/">开发经验</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构与算法/">数据结构与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/01/28/MySQL学习笔记/">MySQL学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/27/基础排序-冒泡排序及其变体/">基础排序-冒泡排序及其变体</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/09/Rails响应请求的过程/">Rails 响应 Web 请求的过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/26/Spring-中的-refresh-方法/">Spring 中的 refresh()方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/20/JVM的运行时数据区域、垃圾回收以及类加载机制/">JVM的运行时数据区域、垃圾回收以及类加载机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/30/MacOS-10-15-安装-Rails-环境/">MacOS 10.15 安装 Rails 环境</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/10/Scala-中的尾递归/">Scala 中的尾递归</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/28/解决-MacOS-下-sbt-加载慢的问题/">解决 MacOS 下 sbt 加载慢的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/23/Spring-中的组件注册/">Spring 中的组件注册</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/12/位运算的相关知识/">位运算的常见使用方式</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">编程学习记录</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>