<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Java初级面试题-Java多线程篇 | jiangwr</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java初级面试题-Java多线程篇</h1><a id="logo" href="/.">jiangwr</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java初级面试题-Java多线程篇</h1><div class="post-meta">Jan 2, 2019<span> | </span><span class="category"><a href="/categories/面试/">面试</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h2 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h2><ol>
<li>实现Runnable接口</li>
<li>实现Callable接口</li>
<li>继承Thread类</li>
</ol>
<p>实现Runnable和Callable接口的类只能当作一个可以在线程中运行的任务，不是真正意义上的线程，因为最后还是需要通过Thread类来调用，可以说任务是通过线程驱动而执行的。</p>
<p>实现Runnable接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MyRunnable implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;运行中！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        MyRunnable myRunnable = new MyRunnable();</span><br><span class="line">        Thread thread = new Thread(myRunnable);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现Callable接口</p>
<p>与Runnable相比，Callable可以有返回值，返回值通过FutureTasK封装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MyCallable implements Callable&lt;Integer&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer call() throws Exception &#123;</span><br><span class="line">        return 1024;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        MyCallable myCallable = new MyCallable();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(myCallable);</span><br><span class="line">        Thread thread = new Thread(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承Thread类</p>
<p>因为Thread类也实现了Runnable接口，因此同样需要实现run()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">     System.out.println(&quot;Hello world!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        MyThread myThread = new MyThread();</span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现接口的方式与继承Thread比较</p>
<p>实现接口可能更好一些：1.Java不支持多继承2.类可能只要求可以执行就好了，继承整个类开销过大。</p>
<h2 id="sleep-、join-、yield-的区别"><a href="#sleep-、join-、yield-的区别" class="headerlink" title="sleep()、join()、yield()的区别"></a>sleep()、join()、yield()的区别</h2><p><strong>Thread.sleep()</strong>方法会休眠当前正在执行的线程，休眠时间单位为毫秒。sleep()可能抛出InterruptedException异常，因为异常不能跨线程传播，因此须在本地处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class MySleep implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(System.currentTimeMillis());</span><br><span class="line">            Thread.sleep(10000);</span><br><span class="line">            System.out.println(System.currentTimeMillis());</span><br><span class="line">        &#125;catch (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        MySleep mySleep = new MySleep();</span><br><span class="line">        Thread thread = new Thread(mySleep);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>yield方法</strong></p>
<p>调用静态方法yield()说明当前线程已经完成了生命周期中最重要的部分，可以切换给其他线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其他线程可以运行。</p>
<h2 id="CountDownLatch与CyclicBarrier"><a href="#CountDownLatch与CyclicBarrier" class="headerlink" title="CountDownLatch与CyclicBarrier"></a>CountDownLatch与CyclicBarrier</h2><p><strong>CountDownLatch</strong></p>
<p>用来控制一个线程等待多个线程。</p>
<p>原理:维护一个计数器，每次调用countDown()方法会让计数器的值减1，减到0的时候，那些因为调用await()方法而等待的线程会被唤醒。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MyCountDownLatch &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        final int totalThread = 10;</span><br><span class="line">        CountDownLatch countDownLatch = new CountDownLatch(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        for (int i=0;i&lt;totalThread;i++)&#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                System.out.println(&quot;Hello &quot;);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(&quot;World&quot;);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CyclicBarrier</strong></p>
<p>用来控制多线程互相等待，只有这些线程都等待时，这些线程才会继续执行。</p>
<p>原理:维护一个计数器，线程执行await()方法之后，计数器减1并等待，直到计数器为0，所有调用await()方法的线程才能继续执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class MyCyclicBarrier &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        final int totalThread = 10;</span><br><span class="line">        CyclicBarrier cyclicBarrier = new CyclicBarrier(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        for (int i=0;i&lt;totalThread;i++)&#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                System.out.println(&quot;Hello&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125;catch (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; catch (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;World&quot;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CyclicBarrier与CountDownLatch的一个区别是，CyclicBarrier的计数器可以通过调用<code>cyclicBarrier.reset()</code>方法循环使用，所以又被称为循环屏障。</p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class MySemaphore &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        final int clientCount = 3;</span><br><span class="line">        final int totalRequstCount = 10;</span><br><span class="line">        Semaphore semaphore = new Semaphore(clientCount);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        for (int i=0;i&lt;totalRequstCount;i++)&#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(semaphore.availablePermits());</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;finally &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure>
<p>ThreadPoolExecutor的7个核心参数:</p>
<ol>
<li>corePoolSize:核心线程池大小。在创建线程之后，默认情况下，线程池没有任何线程，而是等待任务到来才创建线程区执行任务。</li>
<li>maximumPoolSize:线程池允许的最大线程数。当任务数比corePoolSize大时，任务添加到workQueue中，当workQueue满了，将继续创建线程以处理任务。</li>
<li>keepAliveTime:只有当线程池中的线程数量大于核心线程数时，这个参数才会起作用，多余的空闲线程等待任务的最长时间。</li>
<li>unit: keepAliveTime的时间单位</li>
<li>workQueue:存储没来得及执行的任务</li>
<li>threadFactory:执行程序创建线程时使用的工厂</li>
<li>handler:因为超出线程池容量范围和队列容量而执行的处理程序</li>
</ol>
<h2 id="Exector"><a href="#Exector" class="headerlink" title="Exector"></a>Exector</h2><p>Exector管理多个异步任务的执行，而无需开发人员显式地管理线程的生命周期。这里的异步指多个任务执行互不干扰，不需要同步操作。</p>
<ol>
<li>CachedThreadPool:一个任务创建一个线程</li>
<li>FixedThreadPool:所有任务只能使用固定大小的线程</li>
<li>SingleThreadExecutor:相当于大小为1的FixedThreadPool</li>
</ol>
<p><em>拓展</em></p>
<p><strong>阿里编码规范插件给出的建议</strong>:线程池不允许使用Exectors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p>
<p>说明:Exectors各个方法的弊端:</p>
<ul>
<li>newFixedThreadPool和newSingleThreadExecutor:主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。</li>
<li>newCachedThreadPool和newScheduledThreadPool:主要问题是最大线程数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2></li>
</ul>
<p>通俗来讲，线程对于一个volatile变量的修改，对于其他线程是可见的。即线程每次获取的volatile变量的值都是最新的。</p>
<p>汇编代码层面用Lock前缀指令</p>
<ol>
<li>将当前cpu缓存行的数据写回主内存中。</li>
<li>这个写回主内存的操作会导致其他CPU缓存里该内存地址的数据失效。</li>
</ol>
<p>volatile的可见性与禁止重排序是基于内存屏障(Memory Barrier)实现的。内存屏障又称为内存栅栏，是一个CPU指令。在程序运行时，为了提高执行性能，编译器和处理器会对指令进行，插入一条内存屏障会告诉编译器和CPU，不管什么指令都不能和这条内存屏障重排序。</p>
<h2 id="synchronized与lock"><a href="#synchronized与lock" class="headerlink" title="synchronized与lock"></a>synchronized与lock</h2><p>用法比较: </p>
<ol>
<li>lock使用比较灵活，但必须手动获取和释放锁。</li>
<li>lock只适用于代码块，synchronized可用于方法和代码块。</li>
<li>lock可以控制公平性。</li>
<li>lock可以中断地获取锁，中断异常将被抛出，锁会被释放。</li>
</ol>
<p><strong>ReetrantLock</strong>是Lock的实现类，是一个互斥的同步器，在多线程高竞争的条件下，ReetrantLock比synchronized有更加优异的性能表现。</p>
<p>ReetrantLock主要利用CAS+CLH队列(带头节点的双向非循环队列)实现，它支持公平锁和非公平锁。</p>
<p>基本实现:先通过CAS获取锁，如果此时已经有线程占据了锁，那就加入CLH队列并挂起。当锁被释放后，排在CLH队首的线程会被唤醒，然后通过CAS再次获取锁。</p>
<p>如果此时是公平锁:并且同时还有另一线程进来尝试获取锁，当它发现自己不是队首时，会排到队尾，由队首线程获取到锁。</p>
<p>如果此时是非公平锁:并且同时还有另一线程进来获取锁，那么有可能让这个线程先获取。</p>
<p><strong>synchronized</strong></p>
<p>synchronized代码块是由一对monitorenter/monitorexit指令实现的。</p>
<p>类型上可以分为偏斜锁、轻量级锁、重量级锁</p>
<p>当没有竞争，默认使用偏斜锁，JVM利用CAS操作在对象头上的Mark Word部分设置线程Id，如果有另外的线程试图锁定某个被偏斜过的对象，则升级成轻量级锁，轻量级锁依赖CAS操作Mark Word来获取锁，如果成功，就使用轻量级锁，否则，进一步升级成为重量级锁。</p>
<p><em>拓展</em><br> <strong>自旋锁</strong>:竞争锁失败的线程，并不会真实的在操作系统层面挂起等待，而是让JVM做几个空循环，在经过若干循环之后，如果可以获取锁，那么进入临界区，如果还不能获取锁，才会将线程挂起。<br><strong>重入</strong>:由于内置锁是可重入的，因此如果某个线程试图获得一个已经由他自己持有的锁，那么这个请求就会成功。”重入”意味着获取锁的操作的粒度是”线程”，而不是调用。重入的实现方式是，为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置为1。如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数值会相应递减。当计数值为0时，这个锁将被释放。(内置锁:每个Java对象都可以用做一个实现同部的锁，这些锁被称为内置锁(Intrinsic Lock)或者监视器(Monitor Lock)–《Java并发编程实战》)</p>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS是非阻塞同步的。</p>
<p>CAS指令需要三个操作数，分别是内存地址V，旧的预期值A和新值B。当执行操作时，只有当V的值等于A,才将V的值更新为B。</p>
<p><strong>ABA问题</strong></p>
<p>如果一个变量初次读取的时候是A值，它的值被改成了B，后来又被改回A,那CAS操作会误认为它从来没有被改变过。通过原子引用类AtomicStampedReference来控制变量值的版本来解决这个问题。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>极客时间 杨晓峰的Java专栏</li>
<li>《Java并发编程实战》</li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98" target="_blank" rel="noopener">CyC2018/CS-Notes</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/22820761" target="_blank" rel="noopener">美团技术团队-分布式系统互斥性与幂等性问题的分析与解决</a></li>
</ol>
</div><div class="tags"><a href="/tags/Java/">Java</a></div><div class="post-nav"><a class="pre" href="/2019/01/02/面试常见的String问题/">面试常见的String问题</a><a class="next" href="/2019/01/02/Java初级面试题-JVM篇/">Java初级面试题-JVM篇</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java基础/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web技术/">Web技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发经验/">开发经验</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/面试/">面试</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/数据库事务/" style="font-size: 15px;">数据库事务</a> <a href="/tags/HTTPS/" style="font-size: 15px;">HTTPS</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/IDEA/" style="font-size: 15px;">IDEA</a> <a href="/tags/Mac/" style="font-size: 15px;">Mac</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/计算机网络/" style="font-size: 15px;">计算机网络</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/tags/单例模式/" style="font-size: 15px;">单例模式</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/WebSocket/" style="font-size: 15px;">WebSocket</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/01/21/Spring-Boot中使用AOP输出接口请求参数与返回值/">Spring Boot中使用AOP输出接口请求参数与返回值</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/04/Mac启动台删除无效图标/">Mac启动台删除无效图标</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/04/Mac上Intelij-IDEA启动速度慢/">Mac上Intelij IDEA启动速度慢</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/02/ConcurrentHashMap/">ConcurrentHashMap</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/02/HashMap1-7与1-8以及相关问题/">HashMap1.7与1.8以及相关问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/02/面试常见的String问题/">面试常见的String问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/02/Java初级面试题-Java多线程篇/">Java初级面试题-Java多线程篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/02/Java初级面试题-JVM篇/">Java初级面试题-JVM篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/02/Java初级面试题-Java基础篇/">Java初级面试题-Java基础篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/02/Java初级面试题-计算机网络篇/">Java初级面试题-计算机网络篇</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://huarongxie.com/" title="华容谢" target="_blank">华容谢</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">jiangwr.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>