<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Spring Web MVC 文档阅读笔记 | jiangweirong</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Spring Web MVC 文档阅读笔记</h1><a id="logo" href="/.">jiangweirong</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Spring Web MVC 文档阅读笔记</h1><div class="post-meta">Jan 20, 2019</div><div class="post-content"><p>Spring MVC 官方文档的阅读笔记。</p>
<a id="more"></a>
<h1 id="Spring-Web-MVC"><a href="#Spring-Web-MVC" class="headerlink" title="Spring Web MVC"></a>Spring Web MVC</h1><p>&emsp;&emsp;Spring Web MVC 是基于Servlet API构建的原始Web框架，其正式名称“Spring Web MVC”来自它的源模块(Spring-webmvc)的名称，但它更常见的名称是“Spring MVC”。</p>
<h2 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h2><p>&emsp;&emsp;与许多其他web框架一样，Spring MVC是围绕前端控制器模式设计的，其中一个中央Servlet DispatcherServlet提供了一个用于请求处理的共享算法，而实际工作是由可配置的委托组件执行的。该模型灵活，支持多种工作流。</p>
<p>&emsp;&emsp;DispatcherServlet和任何Servlet一样，需要使用Java代码或者web.xml配置。然后，DispatcherServlet使用Spring配置来发现请求映射、视图解析、异常处理等所需的委托组件。</p>
<p>下面的Java配置示例注册并初始化DispatcherServlet:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebApplicationInitializer</span> <span class="keyword">implements</span> <span class="title">WebApplicationInitializer</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> onStartup(ServletContext servletCxt) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 applicationContext</span></span><br><span class="line">        AnnotationConfigWebApplicationContext ac = <span class="keyword">new</span> AnnotationConfigWebApplicationContext();</span><br><span class="line">        ac.register(AppConfig.<span class="keyword">class</span>);</span><br><span class="line">        ac.refresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 DispatcherServlet 并加载其配置</span></span><br><span class="line">        DispatcherServlet servlet = <span class="keyword">new</span> DispatcherServlet(ac);</span><br><span class="line">        ServletRegistration.Dynamic registration = servletCxt.addServlet(<span class="string">"app"</span>, servlet);</span><br><span class="line">        registration.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        registration.addMapping(<span class="string">"/app/*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的web.xml配置示例注册并初始化DispatcherServlet:</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">&lt;web-app&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="params">&lt;listener&gt;</span></span><br><span class="line">        <span class="params">&lt;listener-class&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="params">&lt;/listener-class&gt;</span></span><br><span class="line">    <span class="params">&lt;/listener&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="params">&lt;context-param&gt;</span></span><br><span class="line">        <span class="params">&lt;param-name&gt;</span>contextConfigLocation<span class="params">&lt;/param-name&gt;</span></span><br><span class="line">        <span class="params">&lt;param-value&gt;</span>/WEB-INF/app-context.xml<span class="params">&lt;/param-value&gt;</span></span><br><span class="line">    <span class="params">&lt;/context-param&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="params">&lt;servlet&gt;</span></span><br><span class="line">        <span class="params">&lt;servlet-name&gt;</span>app<span class="params">&lt;/servlet-name&gt;</span></span><br><span class="line">        <span class="params">&lt;servlet-class&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="params">&lt;/servlet-class&gt;</span></span><br><span class="line">        <span class="params">&lt;init-param&gt;</span></span><br><span class="line">            <span class="params">&lt;param-name&gt;</span>contextConfigLocation<span class="params">&lt;/param-name&gt;</span></span><br><span class="line">            <span class="params">&lt;param-value&gt;</span><span class="params">&lt;/param-value&gt;</span></span><br><span class="line">        <span class="params">&lt;/init-param&gt;</span></span><br><span class="line">        <span class="params">&lt;load-on-startup&gt;</span><span class="number">1</span><span class="params">&lt;/load-on-startup&gt;</span></span><br><span class="line">    <span class="params">&lt;/servlet&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="params">&lt;servlet-mapping&gt;</span></span><br><span class="line">        <span class="params">&lt;servlet-name&gt;</span>app<span class="params">&lt;/servlet-name&gt;</span></span><br><span class="line">        <span class="params">&lt;url-pattern&gt;</span><span class="meta-keyword">/app/</span>*<span class="params">&lt;/url-pattern&gt;</span></span><br><span class="line">    <span class="params">&lt;/servlet-mapping&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="params">&lt;/web-app&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Context-Hierarchy-上下文层级关系"><a href="#Context-Hierarchy-上下文层级关系" class="headerlink" title="Context Hierarchy(上下文层级关系)"></a>Context Hierarchy(上下文层级关系)</h3><p>&emsp;&emsp;DispatcherServlet需要一个WebApplicationContext(一个普通ApplicationContext的扩展)来进行自己的配置。WebApplicationContext有一个指向ServletContext及其关联的Servlet的链接。它还绑定到ServletContext，以便应用程序可以在requestcontext tutils上使用静态方法来查找需要访问的WebApplicationContext。</p>
<p>&emsp;&emsp;对于许多应用程序，只有一个WebApplicationContext就足够了。还可以有一个上下文层次结构，其中一个Root WebApplicationContext在多个DispatcherServlet(或其他Servlet)实例之间共享，每个实例都有自己的子WebApplicationContext配置。</p>
<p>&emsp;&emsp;Root WebApplicationContext通常包含基础设施bean，比如需要跨多个Servlet实例共享的数据存储库和业务服务。这些bean可以有效地继承，并且可以在特定于Servlet的子WebApplicationContext中重写(即重新声明)，该上下文通常包含给定Servlet的本地bean。下图显示了这种关系:</p>
<p><img src="/2019/01/20/Spring-Web-MVC-文档阅读笔记/Context Hierarchy.png" alt=""></p>
<p>下面的示例配置WebApplicationContext层级结构:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Class</span>&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Class</span>&lt;?&gt;[] &#123; <span class="type">RootConfig</span>.<span class="keyword">class</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Class</span>&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Class</span>&lt;?&gt;[] &#123; <span class="type">App1Config</span>.<span class="keyword">class</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">String</span>[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">String</span>[] &#123; <span class="string">"/app1/*"</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果不需要应用程序上下文层次结构，应用程序可以通过getRootConfigClasses()返回所有配置，并从getServletConfigClasses()返回null。</p>
<p>下面的例子展示了web.xml的等价版本:</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">&lt;web-app&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="params">&lt;listener&gt;</span></span><br><span class="line">        <span class="params">&lt;listener-class&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="params">&lt;/listener-class&gt;</span></span><br><span class="line">    <span class="params">&lt;/listener&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="params">&lt;context-param&gt;</span></span><br><span class="line">        <span class="params">&lt;param-name&gt;</span>contextConfigLocation<span class="params">&lt;/param-name&gt;</span></span><br><span class="line">        <span class="params">&lt;param-value&gt;</span>/WEB-INF/root-context.xml<span class="params">&lt;/param-value&gt;</span></span><br><span class="line">    <span class="params">&lt;/context-param&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="params">&lt;servlet&gt;</span></span><br><span class="line">        <span class="params">&lt;servlet-name&gt;</span>app1<span class="params">&lt;/servlet-name&gt;</span></span><br><span class="line">        <span class="params">&lt;servlet-class&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="params">&lt;/servlet-class&gt;</span></span><br><span class="line">        <span class="params">&lt;init-param&gt;</span></span><br><span class="line">            <span class="params">&lt;param-name&gt;</span>contextConfigLocation<span class="params">&lt;/param-name&gt;</span></span><br><span class="line">            <span class="params">&lt;param-value&gt;</span>/WEB-INF/app1-context.xml<span class="params">&lt;/param-value&gt;</span></span><br><span class="line">        <span class="params">&lt;/init-param&gt;</span></span><br><span class="line">        <span class="params">&lt;load-on-startup&gt;</span><span class="number">1</span><span class="params">&lt;/load-on-startup&gt;</span></span><br><span class="line">    <span class="params">&lt;/servlet&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="params">&lt;servlet-mapping&gt;</span></span><br><span class="line">        <span class="params">&lt;servlet-name&gt;</span>app1<span class="params">&lt;/servlet-name&gt;</span></span><br><span class="line">        <span class="params">&lt;url-pattern&gt;</span><span class="meta-keyword">/app1/</span>*<span class="params">&lt;/url-pattern&gt;</span></span><br><span class="line">    <span class="params">&lt;/servlet-mapping&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="params">&lt;/web-app&gt;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果不需要应用程序上下文层次结构，应用程序可能只配置一个“根”上下文，并保留contextConfigLocation Servlet参数为空。</p>
<h3 id="Special-Bean-Types-特殊的Bean类型"><a href="#Special-Bean-Types-特殊的Bean类型" class="headerlink" title="Special Bean Types(特殊的Bean类型)"></a>Special Bean Types(特殊的Bean类型)</h3><p>&emsp;&emsp;DispatcherServlet将委托给特殊bean来处理请求并呈现适当的响应。所谓“特殊bean”是指实现框架契约的spring托管对象实例。这些通常带有内置的契约，但是您可以定制它们的属性并扩展或替换它们。</p>
<p>下表列出了DispatcherServlet检测到的特殊bean:</p>
<table>
<thead>
<tr>
<th><strong>Bean type</strong></th>
<th><strong>Explanation</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>HandlerMapping</td>
<td>将请求连同用于预处理和后处理的拦截器列表映射到处理程序。映射基于一些标准，这些标准的细节因HandlerMapping实现而异。<br>两个主要的HandlerMapping实现是RequestMappingHandlerMapping(它支持@RequestMapping带注释的方法)和SimpleUrlHandlerMapping(它为处理程序维护URI路径模式的显式注册)。</td>
</tr>
<tr>
<td>HandlerAdapter</td>
<td>帮助DispatcherServlet调用映射到请求的处理程序，而不管实际如何调用该处理程序。例如，调用带注释的控制器需要解析注释。HandlerAdapter的主要目的是保护DispatcherServlet不受此类细节的影响。</td>
</tr>
<tr>
<td><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-exceptionhandlers" target="_blank" rel="noopener"><code>HandlerExceptionResolver</code></a></td>
<td>解决异常的策略，可能将异常映射到处理程序、HTML错误视图或其他目标。</td>
</tr>
<tr>
<td><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-viewresolver" target="_blank" rel="noopener"><code>ViewResolver</code></a></td>
<td>将从处理程序返回的基于逻辑字符串的视图名称解析为要呈现给响应的实际视图。</td>
</tr>
<tr>
<td><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-localeresolver" target="_blank" rel="noopener"><code>LocaleResolver</code></a>, <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-timezone" target="_blank" rel="noopener">LocaleContextResolver</a></td>
<td>解析客户端正在使用的地区和可能的时区,以便能够提供国际化的视图。</td>
</tr>
<tr>
<td><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-themeresolver" target="_blank" rel="noopener"><code>ThemeResolver</code></a></td>
<td>解析web应用程序可以使用的主题——例如，提供个性化的布局。</td>
</tr>
<tr>
<td><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-multipart" target="_blank" rel="noopener"><code>MultipartResolver</code></a></td>
<td>在一些多部分解析库的帮助下解析多部分请求(例如，浏览器表单文件上上传)的抽象。</td>
</tr>
<tr>
<td><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-flash-attributes" target="_blank" rel="noopener"><code>FlashMapManager</code></a></td>
<td>存储和检索“输入”和“输出”FlashMap，它们可用于将属性从一个请求传递到另一个请求，通常是通过重定向。</td>
</tr>
</tbody>
</table>
<h3 id="Web-MVC-Config"><a href="#Web-MVC-Config" class="headerlink" title="Web MVC Config"></a>Web MVC Config</h3><p>&emsp;&emsp;应用程序可以声明以处理请求所需的特殊Bean类型列出的基础设施Bean。DispatcherServlet检查每个特殊bean的WebApplicationContext。如果没有匹配的bean类型，它将返回DispatcherServlet.properties中列出的默认类型。</p>
<p>&emsp;&emsp;在大多数情况下，MVC配置是最好的起点。它以Java或XML声明所需的bean，并提供一个更高级别的配置回调API来定制它。</p>
<!--Spring Boot依赖于MVC Java配置来配置Spring MVC，并提供了许多额外的方便选项。-->
<h3 id="Servlet-Config"><a href="#Servlet-Config" class="headerlink" title="Servlet Config"></a>Servlet Config</h3><p>&emsp;&emsp;在Servlet 3.0+环境中，您可以选择以编程方式配置Servlet容器作为替代方案，或者与web.xml文件结合使用。下面的例子注册了一个DispatcherServlet:</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.WebApplicationInitializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebApplicationInitializer</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">WebApplicationInitializer</span></span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> void onStartup(ServletContext container) &#123;</span><br><span class="line">        XmlWebApplicationContext appContext = <span class="keyword">new</span> <span class="type">XmlWebApplicationContext</span>();</span><br><span class="line">        appContext.setConfigLocation(<span class="string">"/WEB-INF/spring/dispatcher-config.xml"</span>);</span><br><span class="line"></span><br><span class="line">        ServletRegistration.<span class="keyword">Dynamic</span> registration = container.addServlet(<span class="string">"dispatcher"</span>, <span class="keyword">new</span> <span class="type">DispatcherServlet</span>(appContext));</span><br><span class="line">        registration.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        registration.addMapping(<span class="string">"/"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;WebApplicationInitializer是Spring MVC提供的一个接口，它确保检测到您的实现并自动用于初始化Servlet 3容器。WebApplicationInitializer的抽象基类实现AbstractDispatcherServletInitializer通过覆盖指定servlet映射和DispatcherServlet配置位置的方法，使注册DispatcherServlet更加容易。</p>
<p>&emsp;&emsp;对于使用基于java的Spring配置的应用程序，建议这样做，如下面的示例所示:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Class</span>&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Class</span>&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Class</span>&lt;?&gt;[] &#123; <span class="type">MyWebConfig</span>.<span class="keyword">class</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">String</span>[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">String</span>[] &#123; <span class="string">"/"</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果使用基于xml的Spring配置，应该直接从AbstractDispatcherServletInitializer扩展，如下面的示例所示:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractDispatcherServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">WebApplicationContext</span> createRootApplicationContext() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">WebApplicationContext</span> createServletApplicationContext() &#123;</span><br><span class="line">        <span class="type">XmlWebApplicationContext</span> cxt = <span class="keyword">new</span> <span class="type">XmlWebApplicationContext</span>();</span><br><span class="line">        cxt.setConfigLocation(<span class="string">"/WEB-INF/spring/dispatcher-config.xml"</span>);</span><br><span class="line">        <span class="keyword">return</span> cxt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">String</span>[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">String</span>[] &#123; <span class="string">"/"</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;AbstractDispatcherServletInitializer还提供了一种方便的方法来添加过滤器实例，并将它们自动映射到DispatcherServlet，如下面的示例所示:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractDispatcherServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Filter</span>[] getServletFilters() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Filter</span>[] &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="type">HiddenHttpMethodFilter</span>(), <span class="keyword">new</span> <span class="type">CharacterEncodingFilter</span>() &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;每个过滤器都根据其具体类型添加一个默认名称，并自动映射到DispatcherServlet。</p>
<p>&emsp;&emsp;AbstractDispatcherServletInitializer的isAsyncSupported protected方法提供了一个位置来在DispatcherServlet和映射到它的所有过滤器上启用异步支持。默认情况下，此标志设置为true。</p>
<p>&emsp;&emsp;最后，如果需要进一步定制DispatcherServlet本身，可以覆盖createDispatcherServlet方法。</p>
<h3 id="Processing-处理流程"><a href="#Processing-处理流程" class="headerlink" title="Processing(处理流程)"></a>Processing(处理流程)</h3><p>&emsp;&emsp;DispatcherServlet处理请求的方式如下:</p>
<ol>
<li><p>在请求中搜索WebApplicationContext并将其绑定为控制器和流程中的其他元素可以使用的属性。默认情况下，它是在DispatcherServlet下绑定的。WEB_APPLICATION_CONTEXT_ATTRIBUTE关键。</p>
</li>
<li><p>语言环境解析器绑定到请求，以便让流程中的元素解析处理请求时使用的语言环境(呈现视图、准备数据，等等)。如果不需要区域设置解析器，则不需要区域设置解析器。</p>
</li>
<li><p>主题解析器被绑定到让视图等元素决定使用哪个主题的请求。如果不使用主题，可以忽略它。</p>
</li>
<li><p>如果指定了多部分文件解析器，将检查请求的多部分。如果找到多部分，则将请求封装在MultipartHttpServletRequest中，以便进程中的其他元素进行进一步处理。有关多部件处理的详细信息，请参阅多部件解析器。</p>
</li>
<li><p>搜索适当的处理程序。如果找到处理程序，则执行与处理程序(预处理程序、后处理程序和控制器)相关联的执行链，以便准备模型或呈现。另外，对于带注释的控制器，可以呈现响应(在HandlerAdapter中)，而不是返回视图。</p>
</li>
<li><p>如果返回模型，则呈现视图。如果没有返回模型(可能是由于预处理程序或后处理程序拦截了请求，也可能是出于安全原因)，则不会呈现视图，因为请求已经被执行了。</p>
</li>
</ol>
<p>&emsp;&emsp;在WebApplicationContext中声明的HandlerExceptionResolver bean用于解决请求处理期间抛出的异常。这些异常解析器允许定制逻辑来处理异常。有关更多细节，请参见例外。</p>
<p>&emsp;&emsp;Spring DispatcherServlet还支持返回Servlet API指定的最后修改日期。确定特定请求的最后修改日期的过程很简单:DispatcherServlet查找适当的处理程序映射，并测试找到的处理程序是否实现LastModified接口。如果是，则将LastModified接口的long getLastModified(request)方法的值返回给客户机。</p>
<p>&emsp;&emsp;您可以通过向web.xml文件中的Servlet声明添加Servlet初始化参数(init-param元素)来定制各个DispatcherServlet实例。下表列出了支持的参数:</p>
<table>
<thead>
<tr>
<th><strong>Parameter</strong></th>
<th><strong>Explanation</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>contextClass</td>
<td>实现ConfigurableWebApplicationContext的类，由这个Servlet实例化并在本地配置。默认情况下，使用XmlWebApplicationContext。</td>
</tr>
<tr>
<td>contextConfigLocation</td>
<td>传递给上下文实例(由contextClass指定)的字符串，以指示可以在何处找到上下文。字符串可能由多个字符串(使用逗号作为分隔符)组成，以支持多个上下文。对于定义了两次bean的多个上下文位置，最新位置优先。</td>
</tr>
<tr>
<td>namespace</td>
<td>WebApplicationContext的名称空间。默认为servlet-name servlet。</td>
</tr>
<tr>
<td>throwExceptionIfNoHandlerFound</td>
<td>当没有为请求找到处理程序时，是否抛出NoHandlerFoundException。然后可以使用HandlerExceptionResolver捕获异常(例如，通过使用@ExceptionHandler控制器方法)，并像处理其他异常一样处理异常。<br>默认情况下，这被设置为false，在这种情况下DispatcherServlet将响应状态设置为404 (NOT_FOUND)，而不会引发异常。<br>注意，如果还配置了缺省servlet处理，未解决的请求总是被转发到缺省servlet，并且从来不会引发404。</td>
</tr>
</tbody>
</table>
<h3 id="Interception-拦截器"><a href="#Interception-拦截器" class="headerlink" title="Interception(拦截器)"></a>Interception(拦截器)</h3><p>&emsp;&emsp;所有HandlerMapping实现都支持处理程序拦截器，当您希望将特定功能应用于特定请求时，这些拦截器非常有用——例如，检查主体。拦截器必须从org.springframework.web实现HandlerInterceptor。servlet包有三种方法，应该提供足够的灵活性来进行各种预处理和后处理:</p>
<p><code>preHandle(..)</code>:在实际处理程序执行之前</p>
<p><code>postHandle(..)</code>:在执行处理程序之后</p>
<p><code>afterCompletion(..)</code>:完成请求后</p>
<p>&emsp;&emsp;preHandle(..)方法返回一个布尔值。可以使用此方法中断或继续执行链的处理。当此方法返回true时，处理程序执行链将继续。当返回false时，DispatcherServlet假定拦截器本身已经处理了请求(例如，呈现了适当的视图)，并且不会继续执行执行链中的其他拦截器和实际处理程序。</p>
<p>&emsp;&emsp;有关如何配置截取程序的示例，请参阅MVC配置一节中的截取程序。您还可以通过在各个HandlerMapping实现上使用setter来直接注册它们。</p>
<p>&emsp;&emsp;注意，postHandle对于@ResponseBody和ResponseEntity方法不太有用，这些方法在HandlerAdapter中以及postHandle之前编写和提交响应。这意味着对响应进行任何更改都太晚了，比如添加额外的头部。对于此类场景，您可以实现ResponseBodyAdvice，并将其声明为控制器通知bean，或者直接在RequestMappingHandlerAdapter上配置它。</p>
<h3 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h3><p>&emsp;&emsp;如果在请求映射期间发生异常，或者从请求处理程序(例如@Controller)抛出异常，DispatcherServlet将委托给HandlerExceptionResolver bean链来解决异常并提供替代处理，这通常是一个错误响应。</p>
<p>下表列出了可用的HandlerExceptionResolver实现:</p>
<table>
<thead>
<tr>
<th>HandlerExceptionResolver</th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>SimpleMappingExceptionResolver</td>
<td>异常类名和错误视图名之间的映射。用于在浏览器应用程序中呈现错误页面。</td>
</tr>
<tr>
<td><a href="https://docs.spring.io/spring-framework/docs/5.1.7.RELEASE/javadoc-api/org/springframework/web/servlet/mvc/support/DefaultHandlerExceptionResolver.html" target="_blank" rel="noopener"><code>DefaultHandlerExceptionResolver</code></a></td>
<td>解决Spring MVC引发的异常，并将它们映射到HTTP状态代码。还请参见备用ResponseEntityExceptionHandler和REST API异常。</td>
</tr>
<tr>
<td>ResponseStatusExceptionResolver</td>
<td>使用@ResponseStatus注释解析异常，并根据注释中的值将异常映射到HTTP状态代码。</td>
</tr>
<tr>
<td>ExceptionHandlerExceptionResolver</td>
<td>通过调用@Controller或@ControllerAdvice类中的@ExceptionHandler方法来解决异常。</td>
</tr>
</tbody>
</table>
<h4 id="Chain-of-Resolvers-解析器链"><a href="#Chain-of-Resolvers-解析器链" class="headerlink" title="Chain of Resolvers(解析器链)"></a>Chain of Resolvers(解析器链)</h4><p>&emsp;&emsp;通过在Spring配置中声明多个HandlerExceptionResolver bean并根据需要设置它们的order属性，可以形成一个异常解析器链。order属性越高，异常解析器的位置就越晚。</p>
<p>&emsp;&emsp;HandlerExceptionResolver的合同规定它可以返回:</p>
<ul>
<li><p>指向错误视图的模型和视图。</p>
</li>
<li><p>如果在解析器中处理了异常，则显示空的ModelAndView。</p>
</li>
<li><p>如果异常仍然未解决，则为null，以便后续解析器尝试;如果异常在最后仍然存在，则允许它向上冒泡到Servlet容器。</p>
</li>
</ul>
<p>&emsp;&emsp;MVC配置自动为默认Spring MVC异常、@ResponseStatus注释异常和@ExceptionHandler方法支持声明内置解析器。您可以自定义该列表或替换它。</p>
<h4 id="Container-Error-Page-容器错误页面"><a href="#Container-Error-Page-容器错误页面" class="headerlink" title="Container Error Page(容器错误页面)"></a>Container Error Page(容器错误页面)</h4><p>&emsp;&emsp;如果任何HandlerExceptionResolver仍然无法解析异常，并且因此需要传播异常，或者如果响应状态设置为错误状态(即4xx、5xx)， Servlet容器可以在HTML中呈现一个默认的错误页面。要定制容器的默认错误页面，可以在web.xml中声明一个错误页面映射。下面的例子说明了如何做到这一点:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/error<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;对于前面的示例，当出现异常或响应有错误状态时，Servlet容器在容器内将错误分派到配置的URL(例如，/error)。然后由DispatcherServlet处理，可能将其映射到@Controller，该控制器可以实现为返回带有模型的错误视图名或呈现JSON响应，如下面的示例所示:</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line"><span class="keyword">public</span> class ErrorController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(path = <span class="string">"/error"</span>)</span><br><span class="line">    <span class="keyword">public</span> Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; handle(HttpServletRequest request) &#123;</span><br><span class="line">        Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt;();</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">"status"</span>, request.getAttribute(<span class="string">"javax.servlet.error.status_code"</span>));</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">"reason"</span>, request.getAttribute(<span class="string">"javax.servlet.error.message"</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!--Servlet API不提供在Java中创建错误页面映射的方法。但是可以同时使用WebApplicationInitializer和最小的web.xml。-->
<h3 id="View-Resolution-视图解析"><a href="#View-Resolution-视图解析" class="headerlink" title="View Resolution(视图解析)"></a>View Resolution(视图解析)</h3><p>&emsp;&emsp;Spring MVC定义了ViewResolver和视图接口，使您可以在浏览器中呈现模型，而不需要绑定到特定的视图技术。ViewResolver提供视图名称和实际视图之间的映射。视图处理在移交给特定视图技术之前的数据准备工作。</p>
<h4 id="Handling-处理"><a href="#Handling-处理" class="headerlink" title="Handling(处理)"></a>Handling(处理)</h4><p>&emsp;&emsp;您可以通过声明多个解析器bean来链接视图解析器，如果需要，还可以通过设置order属性来指定order。记住，order属性越高，视图解析器在链中的位置就越晚。</p>
<p>&emsp;&emsp;ViewResolver的契约指定它可以返回null来表示找不到视图。然而，对于JSP和InternalResourceViewResolver，判断JSP是否存在的惟一方法是通过RequestDispatcher执行分派。因此，必须始终配置一个internal alresourceviewresolver，使其在视图解析器的整体顺序中位于最后。</p>
<p>&emsp;&emsp;配置视图解析与将ViewResolver bean添加到Spring配置中一样简单。MVC配置为视图解析器和添加无逻辑视图控制器提供了专用的配置API，这些视图控制器对于没有控制器逻辑的HTML模板呈现非常有用。</p>
<h4 id="Redirecting-重定向"><a href="#Redirecting-重定向" class="headerlink" title="Redirecting(重定向)"></a>Redirecting(重定向)</h4><p>&emsp;&emsp;视图名称中的特殊重定向:前缀允许执行重定向。UrlBasedViewResolver(及其子类)将其识别为一条需要重定向的指令。视图名称的其余部分是重定向URL。</p>
<p>&emsp;&emsp;最终效果与控制器返回RedirectView相同，但现在控制器本身可以根据逻辑视图名称进行操作。逻辑视图名(如redirect:/myapp/some/resource)相对于当前Servlet上下文重定向，而名称(如redirect: <a href="https://myhost.com/some/仲裁员/path)重定向到绝对URL。" target="_blank" rel="noopener">https://myhost.com/some/仲裁员/path)重定向到绝对URL。</a></p>
<p>&emsp;&emsp;注意，如果用@ResponseStatus注释控制器方法，则注释值优先于RedirectView设置的响应状态。</p>
<h4 id="Forwarding-转发"><a href="#Forwarding-转发" class="headerlink" title="Forwarding(转发)"></a>Forwarding(转发)</h4><p>&emsp;&emsp;您还可以使用一个特殊的forward:前缀来表示最终由UrlBasedViewResolver和子类解析的视图名称。这将创建一个internal alresourceview，它执行RequestDispatcher.forward()。因此，对于InternalResourceViewResolver和InternalResourceView(对于JSP)，这个前缀是没有用的，但是如果您使用另一种视图技术，但是仍然希望强制Servlet/JSP引擎处理资源的转发，那么这个前缀是有用的。请注意，您还可以链接多个视图解析器。</p>
<h3 id="Locale-国际化"><a href="#Locale-国际化" class="headerlink" title="Locale(国际化)"></a>Locale(国际化)</h3><p>&emsp;&emsp;Spring架构的大多数部分都支持国际化，就像Spring web MVC框架一样。DispatcherServlet允许您通过使用客户机的区域设置自动解析消息。这是通过LocaleResolver对象完成的。</p>
<p>&emsp;&emsp;当一个请求传入时，DispatcherServlet会寻找一个语言环境解析器，如果找到了，它会尝试使用它来设置语言环境。通过使用RequestContext.getLocale()方法，您始终可以检索由语言环境解析器解析的语言环境。</p>
<p>&emsp;&emsp;除了自动区域设置解析之外，您还可以将拦截器附加到处理程序映射(有关处理程序映射拦截器的更多信息，请参见拦截)，以在特定环境下更改区域设置(例如，基于请求中的参数)。</p>
<p>&emsp;&emsp;区域设置解析器和拦截器在org.springframework.web.servlet中定义。i18n包，并在应用程序上下文中以正常方式配置。以下区域设置解析器的选择包含在Spring中。</p>
<h4 id="Time-Zone"><a href="#Time-Zone" class="headerlink" title="Time Zone"></a>Time Zone</h4><p>&emsp;&emsp;除了获得客户机的地区之外，了解它的时区通常也很有用。LocaleContextResolver接口提供了对LocaleResolver的扩展，该扩展允许解析器提供更丰富的LocaleContext，其中可能包括时区信息。</p>
<p>&emsp;&emsp;如果可用，可以使用RequestContext.getTimeZone()方法获得用户的时区。任何在Spring的ConversionService中注册的日期/时间转换器和格式化程序对象都会自动使用时区信息。</p>
<h4 id="Header-Resolver"><a href="#Header-Resolver" class="headerlink" title="Header Resolver"></a>Header Resolver</h4><p>&emsp;&emsp;此区域设置解析器检查客户机(例如，web浏览器)发送的请求中的accept-language头。通常，这个头字段包含客户机操作系统的语言环境。注意，此解析器不支持时区信息。</p>
<h4 id="Cookie-Resolver"><a href="#Cookie-Resolver" class="headerlink" title="Cookie Resolver"></a>Cookie Resolver</h4><p>&emsp;&emsp;此区域设置解析器检查客户机上可能存在的Cookie，以查看是否指定了区域设置或时区。如果是，则使用指定的详细信息。通过使用这个区域设置解析器的属性，您可以指定cookie的名称以及最大年龄。下面的例子定义了一个CookieLocaleResolver:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"localeResolver"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.web.servlet.i18n.CookieLocaleResolver"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;property name=<span class="string">"cookieName"</span> value=<span class="string">"clientlanguage"</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- <span class="keyword">in</span> seconds. If set to <span class="number">-1</span>, the cookie is not persisted (deleted when browser shuts down) --&gt;</span><br><span class="line">    &lt;property name=<span class="string">"cookieMaxAge"</span> value=<span class="string">"100000"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/bean&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="Session-Resolver"><a href="#Session-Resolver" class="headerlink" title="Session Resolver"></a>Session Resolver</h4><p>&emsp;&emsp;SessionLocaleResolver允许您从可能与用户请求关联的会话中检索语言环境和时区。与CookieLocaleResolver相反，该策略将本地选择的地区设置存储在Servlet容器的HttpSession中。因此，这些设置对于每个会话都是临时的，因此，当每个会话终止时，这些设置就会丢失。</p>
<p>&emsp;&emsp;注意，它与外部会话管理机制(如Spring会话项目)没有直接关系。这个SessionLocaleResolver根据当前HttpServletRequest计算和修改相应的HttpSession属性。</p>
<h4 id="Locale-Interceptor"><a href="#Locale-Interceptor" class="headerlink" title="Locale Interceptor"></a>Locale Interceptor</h4><p>&emsp;&emsp;您可以通过将LocaleChangeInterceptor添加到HandlerMapping定义之一来启用更改地区。它检测请求中的一个参数并相应地更改区域设置，在dispatcher的应用程序上下文中调用LocaleResolver上的setLocale方法。下一个示例显示调用all *。查看包含名为siteLanguage参数的资源，现在将更改区域设置。例如，一个URL请求<a href="https://www.sf.net/home.view?站点语言=nl，将站点语言更改为荷兰语。下面的例子演示了如何拦截区域设置" target="_blank" rel="noopener">https://www.sf.net/home.view?站点语言=nl，将站点语言更改为荷兰语。下面的例子演示了如何拦截区域设置</a>:</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="built_in">id</span>=<span class="string">"localeChangeInterceptor"</span></span><br><span class="line">        <span class="built_in">class</span>=<span class="string">"org.springframework.web.servlet.i18n.LocaleChangeInterceptor"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"paramName"</span> value=<span class="string">"siteLanguage"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean <span class="built_in">id</span>=<span class="string">"localeResolver"</span></span><br><span class="line">        <span class="built_in">class</span>=<span class="string">"org.springframework.web.servlet.i18n.CookieLocaleResolver"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean <span class="built_in">id</span>=<span class="string">"urlMapping"</span></span><br><span class="line">        <span class="built_in">class</span>=<span class="string">"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"interceptors"</span>&gt;</span><br><span class="line">        &lt;<span class="built_in">list</span>&gt;</span><br><span class="line">            &lt;<span class="keyword">ref</span> bean=<span class="string">"localeChangeInterceptor"</span>/&gt;</span><br><span class="line">        &lt;/<span class="built_in">list</span>&gt;</span><br><span class="line">    &lt;/<span class="keyword">property</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"mappings"</span>&gt;</span><br><span class="line">        &lt;value&gt;/**/*.view=someController&lt;/value&gt;</span><br><span class="line">    &lt;/<span class="keyword">property</span>&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/Spring/">Spring</a></div><div class="post-nav"><a class="pre" href="/2019/03/05/SpringBoot配置HTTPS/">SpringBoot配置HTTPS</a><a class="next" href="/2019/01/19/大数据的基本认识/">大数据的简单认识</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Scala/">Scala</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/书籍阅读/">书籍阅读</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发经验/">开发经验</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构与算法/">数据结构与算法</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Spring/" style="font-size: 15px;">Spring</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/04/05/Redis中的数据结构与对象/">Redis中的数据结构与对象</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/18/二叉树的前中后序遍历/">二叉树的前中后序遍历</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/04/union-find/">union find</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/28/MySQL学习笔记/">MySQL学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/27/基础排序-冒泡排序及其变体/">基础排序-冒泡排序及其变体</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/09/Rails响应请求的过程/">Rails 响应 Web 请求的过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/26/Spring-中的-refresh-方法/">Spring 中的 refresh()方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/20/JVM的运行时数据区域、垃圾回收以及类加载机制/">JVM的运行时数据区域、垃圾回收以及类加载机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/30/MacOS-10-15-安装-Rails-环境/">MacOS 10.15 安装 Rails 环境</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/10/Scala-中的尾递归/">Scala 中的尾递归</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">jiangweirong</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>