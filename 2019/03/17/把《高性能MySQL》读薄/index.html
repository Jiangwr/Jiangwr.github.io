<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>把《高性能MySQL》读薄 | jiangwr</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">把《高性能MySQL》读薄</h1><a id="logo" href="/.">jiangwr</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">把《高性能MySQL》读薄</h1><div class="post-meta">Mar 17, 2019<span> | </span><span class="category"><a href="/categories/书籍阅读/">书籍阅读</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><blockquote>
<p>如果在头脑中构建出一幅 MySQL 各组件之间如何协同工作的架构图，就会有助于深入理解 MySQL 服务器。—《高性能MySQL》</p>
</blockquote>
<h2 id="MySQL的逻辑架构"><a href="#MySQL的逻辑架构" class="headerlink" title="MySQL的逻辑架构"></a>MySQL的逻辑架构</h2><p>​    <img src="/2019/03/17/把《高性能MySQL》读薄/MySQL逻辑架构图.png" alt="MySQL逻辑架构图"></p>
<p>大体来说，MySQL 可以分为 Server 层和存储引擎层两个部分。    </p>
<p>Server层包括了连接器、查询缓存、分析器、优化器、执行器等以及所有的内置函数(例如，日期、时间、数学和加密函数)，所有的跨存储引擎的功能都在这一层实现:存储过程、触发器、视图等。</p>
<p>存储引擎层负责数据的存储和提取。服务器通过 API 与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使得这些差异在上层的查询过程是透明的。在 MySQL 5.5.5版本开始 InnoDB 为默认存储引擎。</p>
<p><strong>连接器</strong>: 连接器负责跟客户端建立连接、获取权限、维持和管理连接。每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个 CPU 核心或者 CPU 中运行。服务器会负责缓存线程，因此不需要为每一个新建的连接创建或者销毁线程(MySQL5.5版本支持线程池插件，可以使用池中少量的线程来服务大量的连接)。</p>
<p><strong>查询缓存</strong>:连接建立之后， select 语句就会先到查询缓存看看，之前是否执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存到内存中。key 为查询的语句，value 为查询的结果。如果命中缓存，则可以直接返回结果给客户端。查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。对于更新压力大的数据库来说，查询缓存的命中率会非常低。需要注意的是，MySQL 8.0 版本直接将查询缓存的整块功能删掉了。</p>
<p><strong>分析器</strong>:MySQL 会解析查询，并创建内部数据结构(解析树)，然后进一步检查解析树是否合法。比如:数据表和数据列是否存在，别名是否有歧义等。如果通过则生成一棵新的解析树，再提交给优化器。</p>
<p><strong>优化器</strong>:对解析树进行各种优化，包括重写查询、决定表的读取顺序，以及选择合适的索引等。用户可以通过特殊的关键字提示优化器，影响它的决策过程。也可以请求优化器解释(explain)优化过程的各个因素。优化器并不关心表使用的是什么存储引擎，但是存储引擎对于优化查询是有影响的。</p>
<p><strong>执行器</strong>:MySQL 通过分析器知道了要做什么，通过优化器知道了该怎么做，于是进入执行器，开始执行语句。</p>
<h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><p>无论何时，只要有多个查询只要在同一时刻修改数据，都会产生并发控制的问题。</p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>在处理并发读或者写时，可以通过实现一个由两种类型的锁组成的锁系统来解决问题。这两种类型的锁通常被称为共享锁(shared lock)和排他锁(exclusive lock)，也被称为读锁(read lock)和写锁(write lock)。</p>
<h3 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h3><p><strong>表锁(table lock)</strong>:表锁是 MySQL 中最基本的锁策略，并且是开销最小的策略。它会锁定整张表。一个用户在进行写操作(插入、删除、更新等)前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取的用户才能获得读锁，读锁之间是不相互阻塞。</p>
<p><strong>行级锁(row lock)</strong>:行级锁可以最大程度地支持并发处理(同时也带来了最大的锁开销)。众所周知，在 InnoDB 和XtraDB，以及其他一些存储引擎实现了行级锁。行级锁只在存储引擎层实现，而不是 MySQL 服务器层。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务就是一组原子性的SQL查询。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败。</p>
<h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><p><strong>原子性(atomicity)</strong></p>
<p> 一个事务必须被视为一个不可分割的最小单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。</p>
<p><strong>一致性(consistency)</strong></p>
<p> 数据库总是从一个一致性的状态转换到另外一个一致性的状态。一致性确保了事务只要没有最终提交，就不会把事务中所作的修改保存到数据库中。</p>
<p><strong>隔离性(isolation)</strong></p>
<p> 通常来说(因为要考虑隔离级别，所以说是通常情况)，一个事务所作的修改在最终提交之前，对其他事务是不可见的。</p>
<p><strong>持久性(durability)</strong></p>
<p> 一旦事务提交，其所作的修改就会永久保存到数据库中。此时即使系统奔溃，修改的数据也不会丢失。持久性是个模糊的概念，因为持久性也分很多级别。有些持久性策略能够提供非常强的安全保障，而有些则未必。而且不可能做到百分之百的持久性保证的策略。</p>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>隔离性其实比想象的要复杂。在SQL标准中定义了四种隔离级别，每一种级别规定了一个事务中所作的修改，哪些在事务间是可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统的开销也更低。</p>
<p><strong>READ UNCOMMITTED(读未提交)</strong></p>
<p>在READ UNCOMMITTED级别，事务中的修改即使是没有提交，对其他事务也是可见的。事务可以读取到未提交的数据，这被称为脏读(Dirty Read)。从性能来说，READ UNCOMMITTED不会比其他级别好太多，但缺乏其他级别的很多优势，所以实际应用很少。</p>
<p><strong>READ COMMITTED(读提交)</strong></p>
<p>大多数数据库的默认隔离级别都是READ COMMITTED(但MySQL不是)。READ COMMITTED满足隔离性的简单定义:一个事务开始时，只能看见已经提交的事务所作的修改。换句话说，一个事务从开始直到提交之前，所作的任何修改对其他事务都是不可见的。这个级别有时候会产生不可重复读(nonrepeatable read)，因为执行两次执行同样的查询，可能会得到不一样的结果。</p>
<p><strong>REPEATABLE READ(可重复读)</strong></p>
<p>REPEATABLE READ解决了脏读，和不可重复读的问题。但是无法解决幻读(Phantom Read)的问题。幻读是指当某个事务在读取某个范围内的记录时，另外一个事务又在范围内插入新的记录，当之前的事务再次读取该范围的记录，会产生幻行(Phantom Row)。InnoDB和XtraDB存储引擎通过多版本并发控制(MVCC)解决了幻读的问题。(可重复读是MySQL的默认事务隔离级别)。</p>
<p><strong>SERIALIZABLE(可串行化)</strong></p>
<p>SERIALIZABLE是最高隔离级别。它通过强制事务串行执行，避免幻读问题。简单来说，SERIALIZABLE会在读取的每一行上都加锁，所以可能导致大量的超时和锁争用的问题。实际应用很少使用该隔离级别，只有在非常需要确保数据一致性而且可以接受没有并发的情况下，才考虑采用该级别。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读可能性</th>
<th>不可重复读可能性</th>
<th>幻读可能性</th>
<th>加锁读</th>
</tr>
</thead>
<tbody>
<tr>
<td>READ UNCOMMITTED</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>READ COMMITTED</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>REPEATABLE READ</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁是指两个或者两个以上的事务在同一个资源上相互占有，并请求锁定对方占用的资源，从而导致恶性循环的现象。死锁发生以后，只有部分或者完全回滚其中一个事务，才能打破死锁。</p>
<h3 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h3><p>事务日志可以帮助提高事务的效率。具体来说，当有记录需要更新的时候，InnoDB 引擎就会把记录写到 redo log 里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面。而不是每次都将修改的数据本身持久到磁盘。事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序 I/O,而不像随机 I/O 需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说快很多。事务日志持久以后，内存中被修改的数据在后台慢慢地刷回到磁盘。目前大多数存储引擎都是这样实现的，通常称之为预写式日志(Write-Ahead Logging),修改数据需要写磁盘两次。</p>
<p>如果数据的修改已经记录到事务日志并持久化，但数据本身没有写会磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。具体的恢复方式则视存储引擎而定。</p>
<h3 id="MySQL-中的事务"><a href="#MySQL-中的事务" class="headerlink" title="MySQL 中的事务"></a>MySQL 中的事务</h3><p>MySQL 提供了两种事务型的存储引擎:InnoDB 和 NDB Cluster。</p>
<p><strong>自动提交(AUTOCOMMIT)</strong></p>
<p>MySQL 默认采用自动提交模式。也就是说，如果不是显式地开始一个事物，则每个查询都被当作一个事务执行提交操作。</p>
<p><strong>在事务中混合使用存储引擎</strong></p>
<p>MySQL的 server 层不管理事务，事务是由下层的存储引擎实现的。所以在同一个事务中使用多种存储引擎是不可靠的。</p>
<p>如果在事务中混合使用了事务型和非事务型的表(例如 InnoDB 和 MyISAM 表)，正常提交的情况下不会有什么问题。如果该事务需要回滚，非事务型的表上的变更就无法撤销，这会导致数据库处于不一致的状态。所以为每张表选择合适的存储引擎非常重要。</p>
<h2 id="多版本并发控制-MVCC"><a href="#多版本并发控制-MVCC" class="headerlink" title="多版本并发控制(MVCC)"></a>多版本并发控制(MVCC)</h2><p>MySQL 的大多数事务型存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，它们一般都同时实现了多版本并发控制(MVCC)。不仅是 MySQL，包括Oracle、PostgreSQL 等其他数据库系统也实现了 MVCC，但是实现机制不尽相同，因为 MVCC 没有一个统一的实现标准。</p>
<p>可以认为 MVCC 是行级锁的一个变种，但是它在多数情况下都避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。</p>
<p>MVCC 的实现，是通过保存数据在某个时间点的快照来实现的。也就是说，不管执行多长时间，每个事物看到的数据都是一致的。根据事务开始时间的不同，每个事物对同一张表，同一时刻看到的数据可能是不一样的。</p>
<p>InnoDB 的 MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间或者删除时间。存储的并不是实际的时间值，而是系统版本号(system version number)。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p>
<p><strong>MVCC在 REPEATABLE READ 隔离级别下的操作</strong></p>
<p><strong>SELECT</strong></p>
<p>InnoDB 会根据以下两个条件检查每行记录:</p>
<p>a.InnDB 只查找版本早于当前事务版本的数据行(也就是，行的系统版本号小于或者等于事务的系统版本号)，这样可以确保事务读取的行，要么是在事务开始前已经存在，要么是事务自身插入或者修改过的。</p>
<p>b.行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。</p>
<p>只有符合上述两个条件的记录，才能返回作为查询的结果。</p>
<p><strong>INSERT</strong></p>
<p>InnoDB 为新插入的每一行保存当前系统版本号作为行版本号。</p>
<p><strong>DELETE</strong></p>
<p>InnoDB 为删除的每一行保存当前系统版本号作为行删除标识。</p>
<p><strong>UPDATE</strong></p>
<p>InnoDB 先插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行的删除标识。</p>
<p>保存这样两个系统版本号，使大多数读操作都可以不用加锁。这样设计使得读操作很简单，性能很好，并且也能保证只会读到符合标准的行。不足之处是每行记录都是需要额外的存储空间，需要做更多的行检查工作以及一些额外的维护工作。</p>
<p>MVCC 只在 REPEATABLE READ 和 READ COMMITTED 两个隔离级别下工作。其他两个隔离级别都和 MVCC 不兼容。因为 READ UNCOMMITTED 总是读到最新的数据行，而不是符合当前事务版本的数据行。SERIALIZABLE 则会对所有读取的行都加锁。</p>
<h2 id="MySQL-的存储引擎"><a href="#MySQL-的存储引擎" class="headerlink" title="MySQL 的存储引擎"></a>MySQL 的存储引擎</h2><h3 id="InnoDB-存储引擎"><a href="#InnoDB-存储引擎" class="headerlink" title="InnoDB 存储引擎"></a>InnoDB 存储引擎</h3><p>InnoDB 是 MySQL 的默认事务型引擎。InnoDB 采用 MVCC 来支持高并发，并且实现了四个标准的隔离级别，其默认级别是 REPEATABLE READ(可重复读)，并且提供间隙锁(next-key locking)策略防止幻读的出现。间隙锁使得 InnoDB 不仅仅锁定查询涉及到的行，还会对索引中的间隙进行锁定，以防止幻行的插入。</p>
<p>InnoDB 表是基于聚簇索引建立的，InnoDB 的索引结果和 MySQL 的其他存储引擎有很大的不同，聚簇索引对主键查询有很高的性能。不过它的二级索引(secondary index，非主键索引)中必须包含主键列，所以如果主键列很大的话，其他的所有索引都会很大。因此，若表上的索引较多的话，主键应当尽可能的小。</p>
<h3 id="MyISAM-存储引擎"><a href="#MyISAM-存储引擎" class="headerlink" title="MyISAM 存储引擎"></a>MyISAM 存储引擎</h3><p>在 MySQL 5.1 及之前的版本， MyISAM 是默认的存储引擎。MyISAM 提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但 MyISAM 不支持事务和行级锁，而且有一个毫无疑问的缺陷就是崩溃后无法安全恢复。</p>
<p><strong>MyISAM 的特性</strong></p>
<ul>
<li>加锁与并发:MyISAM 对整张表加锁，而不是针对行。读取时，会对需要读到的所有表加共享锁，写入时则加排他锁。但是在表有读取查询的同时，也可以往表中插入新的记录(这被称为并发插入，CONCURRENT INSERT)。</li>
<li>修复:对于 MyISAM 表，MySQL 可以手动或者自动执行检查和修复操作，但是这里说的修复和事务恢复以及崩溃恢复不是一个概念。执行表的修复可能导致一些数据的丢失，而且修复操作是非常慢的。可以通过 CHECK TABLE mytable 检查表的错误，如果有错误可以通过执行 REPAIR TABLE mytable 进行修复。另外，如果 MySQL 服务器已经关闭，也可以通过 myisamchk 命令行工具进行检查和修复操作。</li>
<li>索引特性:对于 MyISAM 表，即使是 BLOB 和 TEXT 等长字段，也可以基于其前  500 个字符创建索引。MyISAM 也支持全文索引，这是一种基于分词创建的索引。</li>
<li>延迟更新索引键 (Delayed Key Write):创建 MyISAM 表的时候，如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立刻将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区 (in-memory key buffer)，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入到磁盘。这种方式可以极大地提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。延迟更新索引键的特性，可以在全局设置，也可以为单个表设置。</li>
</ul>
<p><strong>MyISAM 压缩表</strong></p>
<p>如果表在创建并导入数据以后，不会再进行修改操作，那么这样的表或许适合采用 MyISAM 压缩表。可以使用 myisampack 对 MyISAM 表进行压缩(也叫做打包 pack)。压缩表时不能进行修改的(除非先将表解除压缩，修改数据，然后再次压缩)。压缩表可以极大地减少磁盘空间占用，因此也可以减少磁盘 I/O，从而提升查询性能。压缩表也支持索引，但是索引是只读的。</p>
<p><strong>MyISAM 性能</strong></p>
<p>MyISAM 引擎设计简单，数据以紧密格式存储，所以在某些场景下的性能很好。MyISAM 有一些服务器级别的性能扩张限制，比如对索引键缓冲区(key cache)的 Mutex 锁，MariaDB 基于段 (segment) 的索引键缓冲区机制来避免该问题。但 MyISAM 最典型的性能问题还是表锁的问题，如果你发现所有的查询都长期处于”Locked”状态，那么毫无疑问表锁就是罪魁祸首。</p>
<h3 id="Archive-引擎"><a href="#Archive-引擎" class="headerlink" title="Archive 引擎"></a>Archive 引擎</h3><p>Archive 存储引擎只支持 INSERT 和 SELECT 操作，在 MySQL 5.1 之前也不支持索引。</p>
<h3 id="Blackhole-引擎"><a href="#Blackhole-引擎" class="headerlink" title="Blackhole 引擎"></a>Blackhole 引擎</h3><p>Blackhole 引擎没有实现任何的存储机制，它会丢弃所有插入的数据，不做任何保存。但是服务器会记录 Blackhole 表的日志，所以可以用于复制数据到备库，或者只是简单地记录到日志。这种特殊的存储引擎可以在一些特殊的复制架构和日志审核时发挥作用。但这种应用方式会碰到很多问题，因此不推荐。</p>
<h3 id="CSV-引擎"><a href="#CSV-引擎" class="headerlink" title="CSV 引擎"></a>CSV 引擎</h3><p>CSV 引擎可以将普通的 CSV 文件 (逗号分隔值的文件) 作为 MySQL 的表来处理，但这种不支持索引。CSV 引擎可以在数据库运行时拷入或者拷出文件。可以将 Excel 等电子表格软件中的数据存储为 CSV 文件，然后复制到 MySQL 数据目录下，就能在 MySQL 中打开使用。同样，如果将数据写入到一个 CSV 引擎表，其他的外部程序也能立即从表的数据文件中读取 CSV 格式的数据。因此 CSV 引擎可以作为一种数据交换的机制，非常有用。</p>
<h3 id="Federated-引擎"><a href="#Federated-引擎" class="headerlink" title="Federated 引擎"></a>Federated 引擎</h3><p>Federated 引擎是访问其他 MySQL 服务器的一个代理，它会创建一个到远程 MySQL 服务器的客户端连接，并将查询传输到远程服务器执行，然后提取或者发送需要的数据。</p>
<h3 id="Memory-引擎"><a href="#Memory-引擎" class="headerlink" title="Memory 引擎"></a>Memory 引擎</h3><p>如果需要快速地访问数据，并且这些数据不会被修改，重启以后丢失也没有关系，那么使用 Memory 表是非常有用的。Memory 表至少比 MyISAM 表要快一个数量级，因为所有的数据都保存在内存中，不需要进行磁盘 I/O。Memory 表的结构在重启以后还会保留，但数据会丢失。</p>
<p>Memory 表支持 Hash 索引，因此查找操作非常快。虽然 Memory 表的速度非常快，但还是无法取代传统的基于磁盘的表。 Memory 表是表级锁，因此并发写入的性能较低。它不支持 BLOB 或者 TEXT 类型的列，并且每行的长度是固定的，所以即使指定了 VARCHAR ，实际存储时也会转换成 CHAR。</p>
<p>如果 MySQL 在执行查询的过程中需要临时表来保存中间结果，内部使用的临时表就是 Memory 表。如果中间结果太大超出了 Memory 表的限制，或者含有 BLOB 或者 TEXT 字段，则临时表会转换成 MyISAM 表。</p>
<h3 id="Merge-引擎"><a href="#Merge-引擎" class="headerlink" title="Merge 引擎"></a>Merge 引擎</h3><p>Merge 引擎是 MyISAM 引擎的一个变种。Merge 表是由多个 MyISAM 表合并而来的虚拟表。该引擎已被抛弃。</p>
<h2 id="转化表的引擎"><a href="#转化表的引擎" class="headerlink" title="转化表的引擎"></a>转化表的引擎</h2><p>修改表引擎的三种方式。</p>
<h3 id="ALTER-TABLE"><a href="#ALTER-TABLE" class="headerlink" title="ALTER TABLE"></a>ALTER TABLE</h3><p>例如 <code>ALTER TABLE mytable ENGINE = InnoDB</code>；将 mytable 的引擎改为 InnoDB。</p>
<h3 id="导出与导入"><a href="#导出与导入" class="headerlink" title="导出与导入"></a>导出与导入</h3><p>使用 <em>mysqldump</em> 工具将数据导出到文件，然后修改文件中 CREATE TABLE 语句的存储引擎选项。</p>
<h3 id="创建与查询-CREATE-和-SELECT"><a href="#创建与查询-CREATE-和-SELECT" class="headerlink" title="创建与查询 (CREATE 和 SELECT)"></a>创建与查询 (CREATE 和 SELECT)</h3><p>先创建一个新的存储引擎的表，然后利用 INSERT…SELECT 语法来导数据</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">CREATE</span> TABLE innodb_table <span class="keyword">LIKE</span> myisam_table;</span><br><span class="line">mysql&gt; ALTER TABLE innodb_table ENGINE = InnoDB;</span><br><span class="line">mysql&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> innodb_table <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> myisam_table;</span><br></pre></td></tr></table></figure>
<h2 id="MySQL-基准测试"><a href="#MySQL-基准测试" class="headerlink" title="MySQL 基准测试"></a>MySQL 基准测试</h2><h3 id="为什么需要基准测试"><a href="#为什么需要基准测试" class="headerlink" title="为什么需要基准测试?"></a>为什么需要基准测试?</h3><p>基准测试可以观察系统在不同压力下的行为，，评估系统的容量，掌握哪些才是重要的变化，或者观察系统如何处理不同的数据。</p>
<h3 id="基准测试的策略"><a href="#基准测试的策略" class="headerlink" title="基准测试的策略"></a>基准测试的策略</h3><p>基准测试主要有两种策略:一是针对整个系统的整体测试，另外是单独测试 MySQL。这两种策略也被称为集成式 (full-stack) 以及单组件式 (single-component) 基准测试</p>
<h3 id="测试指标"><a href="#测试指标" class="headerlink" title="测试指标"></a>测试指标</h3><ul>
<li><strong>吞吐量</strong>:单位时间内的事务处理数量。</li>
<li><strong>响应时间</strong>:任务所需的整体时间。</li>
<li><strong>并发性</strong>:任意时间有多少同时发生的并发请求。</li>
<li><strong>可扩展性</strong>:简单地说，可扩展性指的是，给系统增加一倍的工作，在理想情况下就能获得两倍的结果 (即吞吐量增加一倍)。或者说，给系统增加一倍的资源 (比如两倍的 CPU 数)，就可以获得两倍的吞吐量。</li>
</ul>
<h3 id="基准测试工具"><a href="#基准测试工具" class="headerlink" title="基准测试工具"></a>基准测试工具</h3><ul>
<li>集成式测试工具:ab 、http_load、JMeter。</li>
<li>单组件式测试工具:mysqlslap、MySQL Benchmark Suite、Super Smack等。</li>
</ul>
<h2 id="MySQL-服务器性能剖析"><a href="#MySQL-服务器性能剖析" class="headerlink" title="MySQL 服务器性能剖析"></a>MySQL 服务器性能剖析</h2><p>我们将性能定义为完成某件任务所需要的时间度量，换句话说，性能即响应时间，这是一个非常重要的原则。</p>
<h2 id="Schema-与数据类型优化"><a href="#Schema-与数据类型优化" class="headerlink" title="Schema 与数据类型优化"></a>Schema 与数据类型优化</h2><p>良好的逻辑设计和物理设计是高性能的基石，所以应该根据系统将要执行的查询语句来设计 schema。</p>
<h3 id="选择优化的数据类型"><a href="#选择优化的数据类型" class="headerlink" title="选择优化的数据类型"></a>选择优化的数据类型</h3><p><strong>更小的通常更好</strong>：一般情况下，应该尽量使用可以正确存储数据的最小数据类型。更小的数据类型通常更快。因为它们占用更少的磁盘、内存和 CPU 缓存，并且处理时需要的 CPU 周期也更少。</p>
<p><strong>简单就好</strong>:简单数据类型的操作通常需要更少的 CPU 周期。例如整型比自负操作代价更低，因为字符集和校对规则使字符比较比整型比较更复杂。这里有两个例子:一个是应该使用 MySQL 内建的类型 date、time、datetime，而不是字符串来存储日期和时间，另外一个是应该用整型来存储 IP 地址。</p>
<p><strong>尽量避免 NULL</strong> :很多表都包含可为 NULL 的列，即使应用程序并不需要保存 NULL 也是如此，这是因为可为 NULL 是列的默认属性。通常情况下，最好指定列为 NOT NULL ，除非真的需要存储 NULL 值。如果查询中包含可为 NULL 的列，对于 MySQL 来说更难优化，因为可为 NULL 的列是的索引、索引统计和值都更加复杂。可为 NULL 的列会使用更多的存储空间，在 MySQL 里也需要特殊处理。</p>
<p>在为列选择数据类型时，第一步需要确定合适的大类型:数字、字符串、时间等。下一步选择具体类型，很多 MySQL 的数据类型可以存储相同类型的数据，只是存储的长度和范围不一样、允许的精度不同，或者需要的物理空间(磁盘和内存空间)不同。例如，DATETIME 和 TIMESTAMP 列都可以存储相同类型的数据:时间和日期，精确到秒。然而 TIMESTAMP 只使用 DATETIME 一半的存储空间，并且会根据时区变化，具有特殊的自动更新能力。另外一个方面， TIMESTAMP 允许的时间范围要小的多，有时候它的特殊能力会成为障碍。</p>
<h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>有两种类型的数字:整数和实数。如果存储整数，可以使用这几种整数类型:TINYINT，SMALLINT，MEDIUMINT，INT，BIGINT。分别使用8,16,,24,32,64位存储空间。它们的可以存储的值的范围从 -2的(N-1) 次到 2的(N-1) - 1，其中 N 为存储空间的位数。</p>
<p>整数类型有可选的 UNSIGNED 属性，表示不允许负值，这大致可以使正数的上限提高一倍。例如,TINYINT UNSIGNED 可以存储的范围为 0 ~ 255，而 TINYINT 的存储范围是 -128 ~ 127。有符号和无符号类型使用相同的存储空间，并具有相同的性能，因此可以根据实际情况选择合适的类型。</p>
<p>MySQL 可以为整数类型指定宽度，例如 INT(11)，这对大多数应用都是没有意义的:它不会限制值的合法范围，只是规定了 MySQL 的一些交互工具用来显示字符的个数。对于存储和计算来说，INT(1) 和 INT(20) 是相同的。</p>
<h3 id="实数类型"><a href="#实数类型" class="headerlink" title="实数类型"></a>实数类型</h3><p>实数是带有小数部分的数字。然而，它们不只是为了存储小数部分；也可以使用 DECIMAL 存储比 BIGINT 还大的整数。MySQL 既支持精确类型，也支持不精确类型。</p>
<p>浮点和 DECIMAL 类型都可以指定精度。对于 DECIMAL 列，可以指定小数点前后所允许的最大位数。这会影响列的空间消耗。MySQL 5.0 以及更高版本将数字打包保存到一个二进制字符串中(每 4 个字节存 9 个数字)。例如，DECIMAL(18,9)小数点两边将各存储 9 个数字，一共使用 9 个字节:小数点前的数字用 4 个字节，小数点后的数字用 4 个字节，小数点本身占 1 个字节。</p>
<p>浮点类型在存储同样范围的值时，通常比 DECIMAL 使用更少的空间。 FLOAT 使用 4 个字节存储。DOUBLE 占用 8 个字节，相比 FLOAT 有更高的精度和更大的范围。</p>
<p>因为需要额外的空间和计算开销，索引尽量只在对小数进行精确计算时才使用 DECIMAL — 例如存储财务数据。但是在数据量比较大的时候，可以考虑使用 BIGINT 代替 DECIMAL ，将需要存储的货币单位根据小数的位数乘以相应的倍数即可。假设要存储财务数据精确到万分之一分，则可以把所有金额乘以一百万，然后将结果存储在 BIGINT 里，这样可以同时避免浮点存储计算不精确和 DECIMAL 精确计算代价高的问题。</p>
<h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>MySQL 支持多种字符串类型，每种类型还有很多变种。从 MySQL 4.1 开始，每个字符串列可以定义自己的字符集和排序规则，或者说校对规则(collation)。这些东西会在很大程度影响性能。</p>
</div><div class="tags"><a href="/tags/MySQL/">MySQL</a></div><div class="post-nav"><a class="next" href="/2019/03/15/使用Spring-Boot创建定时任务/">使用Spring Boot创建定时任务</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java基础/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java多线程/">Java多线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web技术/">Web技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/书籍阅读/">书籍阅读</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发经验/">开发经验</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/HTTPS/" style="font-size: 15px;">HTTPS</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/数据库事务/" style="font-size: 15px;">数据库事务</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/tags/单例模式/" style="font-size: 15px;">单例模式</a> <a href="/tags/计算机网络/" style="font-size: 15px;">计算机网络</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/WebSocket/" style="font-size: 15px;">WebSocket</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/03/17/把《高性能MySQL》读薄/">把《高性能MySQL》读薄</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/15/使用Spring-Boot创建定时任务/">使用Spring Boot创建定时任务</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/05/SpringBoot配置HTTPS/">SpringBoot配置HTTPS</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/13/JVM的运行时数据区域、垃圾回收以及类加载机制/">JVM的运行时数据区域、垃圾回收以及类加载机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/20/SpringBoot-打包的时候报错-BeanCreationException/">SpringBoot 打包的时候报错 BeanCreationException</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/11/MySQL中索引的类型/">MySQL中索引的类型</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/07/MySQL数据库事务、隔离级别以及多版本并发控制-MVCC/">MySQL数据库事务、隔离级别以及多版本并发控制(MVCC)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/03/Spring-Boot中使用AOP输出接口请求参数与返回值/">Spring Boot中使用AOP输出接口请求参数与返回值</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/记录Ant-Design-Pro-Spring-Boot-jar包部署时遇到的坑/">记录Ant Design Pro+Spring Boot jar包部署时遇到的坑</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/01/分布式锁的认识/">分布式锁的认识</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">jiangwr</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>