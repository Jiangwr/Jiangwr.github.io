<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>把《高性能MySQL》读薄 | jiangwr</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">把《高性能MySQL》读薄</h1><a id="logo" href="/.">jiangwr</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">把《高性能MySQL》读薄</h1><div class="post-meta">Mar 17, 2019<span> | </span><span class="category"><a href="/categories/书籍阅读/">书籍阅读</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><blockquote>
<p>如果在头脑中构建出一幅 MySQL 各组件之间如何协同工作的架构图，就会有助于深入理解 MySQL 服务器。—《高性能MySQL》</p>
</blockquote>
<h3 id="MySQL的逻辑架构"><a href="#MySQL的逻辑架构" class="headerlink" title="MySQL的逻辑架构"></a>MySQL的逻辑架构</h3><p>​    <img src="/2019/03/17/把《高性能MySQL》读薄/MySQL逻辑架构图.png" alt="MySQL逻辑架构图"></p>
<p>大体来说，MySQL 可以分为 Server 层和存储引擎层两个部分。    </p>
<p>​    Server层包括了连接器、查询缓存、分析器、优化器、执行器等以及所有的内置函数(例如，日期、时间、数学和加密函数)，所有的跨存储引擎的功能都在这一层实现:存储过程、触发器、视图等。</p>
<p>​    存储引擎层负责数据的存储和提取。服务器通过 API 与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使得这些差异在上层的查询过程是透明的。在 MySQL 5.5.5版本开始 InnoDB 为默认存储引擎。</p>
<p><strong>连接器</strong>: 连接器负责跟客户端建立连接、获取权限、维持和管理连接。每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个 CPU 核心或者 CPU 中运行。服务器会负责缓存线程，因此不需要为每一个新建的连接创建或者销毁线程(MySQL5.5版本支持线程池插件，可以使用池中少量的线程来服务大量的连接)。</p>
<p><strong>查询缓存</strong>:连接建立之后， select 语句就会先到查询缓存看看，之前是否执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存到内存中。key 为查询的语句，value 为查询的结果。如果命中缓存，则可以直接返回结果给客户端。查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。对于更新压力大的数据库来说，查询缓存的命中率会非常低。需要注意的是，MySQL 8.0 版本直接将查询缓存的整块功能删掉了。</p>
<p><strong>分析器</strong>:MySQL 会解析查询，并创建内部数据结构(解析树)，然后进一步检查解析树是否合法。比如:数据表和数据列是否存在，别名是否有歧义等。如果通过则生成一棵新的解析树，再提交给优化器。</p>
<p><strong>优化器</strong>:对解析树进行各种优化，包括重写查询、决定表的读取顺序，以及选择合适的索引等。用户可以通过特殊的关键字提示优化器，影响它的决策过程。也可以请求优化器解释(explain)优化过程的各个因素。优化器并不关心表使用的是什么存储引擎，但是存储引擎对于优化查询是有影响的。</p>
<p><strong>执行器</strong>:MySQL 通过分析器知道了要做什么，通过优化器知道了该怎么做，于是进入执行器，开始执行语句。</p>
<h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><p>无论何时，只要有多个查询只要在同一时刻修改数据，都会产生并发控制的问题。</p>
<h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>在处理并发读或者写时，可以通过实现一个由两种类型的锁组成的锁系统来解决问题。这两种类型的锁通常被称为共享锁(shared lock)和排他锁(exclusive lock)，也被称为读锁(read lock)和写锁(write lock)。</p>
<h4 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h4><p><strong>表锁(table lock)</strong>:表锁是 MySQL 中最基本的锁策略，并且是开销最小的策略。它会锁定整张表。一个用户在进行写操作(插入、删除、更新等)前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取的用户才能获得读锁，读锁之间是不相互阻塞。</p>
<p><strong>行级锁(row lock)</strong>:行级锁可以最大程度地支持并发处理(同时也带来了最大的锁开销)。众所周知，在 InnoDB 和XtraDB，以及其他一些存储引擎实现了行级锁。行级锁只在存储引擎层实现，而不是 MySQL 服务器层。</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务就是一组原子性的SQL查询。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败。</p>
<h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><p><strong>原子性(atomicity)</strong></p>
<p> 一个事务必须被视为一个不可分割的最小单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。</p>
<p><strong>一致性(consistency)</strong></p>
<p> 数据库总是从一个一致性的状态转换到另外一个一致性的状态。一致性确保了事务只要没有最终提交，就不会把事务中所作的修改保存到数据库中。</p>
<p><strong>隔离性(isolation)</strong></p>
<p> 通常来说(因为要考虑隔离级别，所以说是通常情况)，一个事务所作的修改在最终提交之前，对其他事务是不可见的。</p>
<p><strong>持久性(durability)</strong></p>
<p> 一旦事务提交，其所作的修改就会永久保存到数据库中。此时即使系统奔溃，修改的数据也不会丢失。持久性是个模糊的概念，因为持久性也分很多级别。有些持久性策略能够提供非常强的安全保障，而有些则未必。而且不可能做到百分之百的持久性保证的策略。</p>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>隔离性其实比想象的要复杂。在SQL标准中定义了四种隔离级别，每一种级别规定了一个事务中所作的修改，哪些在事务间是可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统的开销也更低。</p>
<p><strong>READ UNCOMMITTED(读未提交)</strong></p>
<p>在READ UNCOMMITTED级别，事务中的修改即使是没有提交，对其他事务也是可见的。事务可以读取到未提交的数据，这被称为脏读(Dirty Read)。从性能来说，READ UNCOMMITTED不会比其他级别好太多，但缺乏其他级别的很多优势，所以实际应用很少。</p>
<p><strong>READ COMMITTED(读提交)</strong></p>
<p>大多数数据库的默认隔离级别都是READ COMMITTED(但MySQL不是)。READ COMMITTED满足隔离性的简单定义:一个事务开始时，只能看见已经提交的事务所作的修改。换句话说，一个事务从开始直到提交之前，所作的任何修改对其他事务都是不可见的。这个级别有时候会产生不可重复读(nonrepeatable read)，因为执行两次执行同样的查询，可能会得到不一样的结果。</p>
<p><strong>REPEATABLE READ(可重复读)</strong></p>
<p>REPEATABLE READ解决了脏读，和不可重复读的问题。但是无法解决幻读(Phantom Read)的问题。幻读是指当某个事务在读取某个范围内的记录时，另外一个事务又在范围内插入新的记录，当之前的事务再次读取该范围的记录，会产生幻行(Phantom Row)。InnoDB和XtraDB存储引擎通过多版本并发控制(MVCC)解决了幻读的问题。(可重复读是MySQL的默认事务隔离级别)。</p>
<p><strong>SERIALIZABLE(可串行化)</strong></p>
<p>SERIALIZABLE是最高隔离级别。它通过强制事务串行执行，避免幻读问题。简单来说，SERIALIZABLE会在读取的每一行上都加锁，所以可能导致大量的超时和锁争用的问题。实际应用很少使用该隔离级别，只有在非常需要确保数据一致性而且可以接受没有并发的情况下，才考虑采用该级别。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读可能性</th>
<th>不可重复读可能性</th>
<th>幻读可能性</th>
<th>加锁读</th>
</tr>
</thead>
<tbody>
<tr>
<td>READ UNCOMMITTED</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>READ COMMITTED</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>REPEATABLE READ</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁是指两个或者两个以上的事务在同一个资源上相互占有，并请求锁定对方占用的资源，从而导致恶性循环的现象。死锁发生以后，只有部分或者完全回滚其中一个事务，才能打破死锁。</p>
<h4 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h4><p>​    事务日志可以帮助提高事务的效率。具体来说，当有记录需要更新的时候，InnoDB 引擎就会把记录写到 redo log 里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面。而不是每次都将修改的数据本身持久到磁盘。事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序 I/O,而不像随机 I/O 需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说快很多。事务日志持久以后，内存中被修改的数据在后台慢慢地刷回到磁盘。目前大多数存储引擎都是这样实现的，通常称之为预写式日志(Write-Ahead Logging),修改数据需要写磁盘两次。</p>
<p>​    如果数据的修改已经记录到事务日志并持久化，但数据本身没有写会磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。具体的恢复方式则视存储引擎而定。</p>
<h4 id="MySQL-中的事务"><a href="#MySQL-中的事务" class="headerlink" title="MySQL 中的事务"></a>MySQL 中的事务</h4><p>​    MySQL 提供了两种事务型的存储引擎:InnoDB 和 NDB Cluster。</p>
<p><strong>自动提交(AUTOCOMMIT)</strong></p>
<p>​    MySQL 默认采用自动提交模式。也就是说，如果不是显式地开始一个事物，则每个查询都被当作一个事务执行提交操作。</p>
<p><strong>在事务中混合使用存储引擎</strong></p>
<p>​    MySQL的 server 层不管理事务，事务是由下层的存储引擎实现的。所以在同一个事务中使用多种存储引擎是不可靠的。</p>
<p>​    如果在事务中混合使用了事务型和非事务型的表(例如 InnoDB 和 MyISAM 表)，正常提交的情况下不会有什么问题。如果该事务需要回滚，非事务型的表上的变更就无法撤销，这会导致数据库处于不一致的状态。所以为每张表选择合适的存储引擎非常重要。</p>
<h3 id="多版本并发控制-MVCC"><a href="#多版本并发控制-MVCC" class="headerlink" title="多版本并发控制(MVCC)"></a>多版本并发控制(MVCC)</h3><p>​    MySQL 的大多数事务型存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，它们一般都同时实现了多版本并发控制(MVCC)。不仅是 MySQL，包括Oracle、PostgreSQL 等其他数据库系统也实现了 MVCC，但是实现机制不尽相同，因为 MVCC 没有一个统一的实现标准。</p>
<p>​    可以认为 MVCC 是行级锁的一个变种，但是它在多数情况下都避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。</p>
<p>​    MVCC 的实现，是通过保存数据在某个时间点的快照来实现的。也就是说，不管执行多长时间，每个事物看到的数据都是一致的。根据事务开始时间的不同，每个事物对同一张表，同一时刻看到的数据可能是不一样的。</p>
<p>​    InnoDB 的 MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间或者删除时间。存储的并不是实际的时间值，而是系统版本号(system version number)。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p>
<p><strong>MVCC在 REPEATABLE READ 隔离级别下的操作</strong></p>
<p><strong>SELECT</strong></p>
<p>InnoDB 会根据以下两个条件检查每行记录:</p>
<p>a.InnDB 只查找版本早于当前事务版本的数据行(也就是，行的系统版本号小于或者等于事务的系统版本号)，这样可以确保事务读取的行，要么是在事务开始前已经存在，要么是事务自身插入或者修改过的。</p>
<p>b.行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。</p>
<p>只有符合上述两个条件的记录，才能返回作为查询的结果。</p>
<p><strong>INSERT</strong></p>
<p>InnoDB 为新插入的每一行保存当前系统版本号作为行版本号。</p>
<p><strong>DELETE</strong></p>
<p>InnoDB 为删除的每一行保存当前系统版本号作为行删除标识。</p>
<p><strong>UPDATE</strong></p>
<p>InnoDB 先插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行的删除标识。</p>
<p>保存这样两个系统版本号，使大多数读操作都可以不用加锁。这样设计使得读操作很简单，性能很好，并且也能保证只会读到符合标准的行。不足之处是每行记录都是需要额外的存储空间，需要做更多的行检查工作以及一些额外的维护工作。</p>
<p>MVCC 只在 REPEATABLE READ 和 READ COMMITTED 两个隔离级别下工作。其他两个隔离级别都和 MVCC 不兼容。因为 READ UNCOMMITTED 总是读到最新的数据行，而不是符合当前事务版本的数据行。SERIALIZABLE 则会对所有读取的行都加锁。</p>
<h3 id="MySQL-的存储引擎"><a href="#MySQL-的存储引擎" class="headerlink" title="MySQL 的存储引擎"></a>MySQL 的存储引擎</h3><h4 id="InnoDB-存储引擎"><a href="#InnoDB-存储引擎" class="headerlink" title="InnoDB 存储引擎"></a>InnoDB 存储引擎</h4><p>​    InnoDB 是 MySQL 的默认事务型引擎。InnoDB 采用 MVCC 来支持高并发，并且实现了四个标准的隔离级别，其默认级别是 REPEATABLE READ(可重复读)，并且提供间隙锁(next-key locking)策略防止幻读的出现。间隙锁使得 InnoDB 不仅仅锁定查询涉及到的行，还会对索引中的间隙进行锁定，以防止幻行的插入。</p>
<p>​    InnoDB 表是基于聚簇索引建立的，InnoDB 的索引结果和 MySQL 的其他存储引擎有很大的不同，聚簇索引对主键查询有很高的性能。不过它的二级索引(secondary index，非主键索引)中必须包含主键列，所以如果主键列很大的话，其他的所有索引都会很大。因此，若表上的索引较多的话，主键应当尽可能的小。</p>
<h4 id="MyISAM-存储引擎"><a href="#MyISAM-存储引擎" class="headerlink" title="MyISAM 存储引擎"></a>MyISAM 存储引擎</h4><p>​    在 MySQL 5.1 及之前的版本， MyISAM 是默认的存储引擎。MyISAM 提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但 MyISAM 不支持事务和行级锁，而且有一个毫无疑问的缺陷就是崩溃后无法安全恢复。</p>
<p><strong>MyISAM 的特性</strong></p>
<ul>
<li>加锁与并发:MyISAM 对整张表加锁，而不是针对行。读取时，会对需要读到的所有表加共享锁，写入时则加排他锁。但是在表有读取查询的同时，也可以往表中插入新的记录(这被称为并发插入，CONCURRENT INSERT)。</li>
<li>修复:对于 MyISAM 表，MySQL 可以手动或者自动执行检查和修复操作，但是这里说的修复和事务恢复以及崩溃恢复不是一个概念。执行表的修复可能导致一些数据的丢失，而且修复操作是非常慢的。可以通过 CHECK TABLE mytable 检查表的错误，如果有错误可以通过执行 REPAIR TABLE mytable 进行修复。另外，如果 MySQL 服务器已经关闭，也可以通过 myisamchk 命令行工具进行检查和修复操作。</li>
<li>索引特性:对于 MyISAM 表，即使是 BLOB 和 TEXT 等长字段，也可以基于其前  500 个字符创建索引。MyISAM 也支持全文索引，这是一种基于分词创建的索引。</li>
<li>延迟更新索引键 (Delayed Key Write):创建 MyISAM 表的时候，如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立刻将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区 (in-memory key buffer)，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入到磁盘。这种方式可以极大地提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。延迟更新索引键的特性，可以在全局设置，也可以为单个表设置。</li>
</ul>
<p><strong>MyISAM 压缩表</strong></p>
<p>​    如果表在创建并导入数据以后，不会再进行修改操作，那么这样的表或许适合采用 MyISAM 压缩表。可以使用 myisampack 对 MyISAM 表进行压缩(也叫做打包 pack)。压缩表时不能进行修改的(除非先将表解除压缩，修改数据，然后再次压缩)。压缩表可以极大地减少磁盘空间占用，因此也可以减少磁盘 I/O，从而提升查询性能。压缩表也支持索引，但是索引是只读的。</p>
<p><strong>MyISAM 性能</strong></p>
<p>​    MyISAM 引擎设计简单，数据以紧密格式存储，所以在某些场景下的性能很好。MyISAM 有一些服务器级别的性能扩张限制，比如对索引键缓冲区(key cache)的 Mutex 锁，MariaDB 基于段 (segment) 的索引键缓冲区机制来避免该问题。但 MyISAM 最典型的性能问题还是表锁的问题，如果你发现所有的查询都长期处于”Locked”状态，那么毫无疑问表锁就是罪魁祸首。</p>
</div><div class="tags"><a href="/tags/MySQL/">MySQL</a></div><div class="post-nav"><a class="next" href="/2019/03/15/使用Spring-Boot创建定时任务/">使用Spring Boot创建定时任务</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java基础/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java多线程/">Java多线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web技术/">Web技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/书籍阅读/">书籍阅读</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发经验/">开发经验</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/HTTPS/" style="font-size: 15px;">HTTPS</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/数据库事务/" style="font-size: 15px;">数据库事务</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/tags/单例模式/" style="font-size: 15px;">单例模式</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/WebSocket/" style="font-size: 15px;">WebSocket</a> <a href="/tags/计算机网络/" style="font-size: 15px;">计算机网络</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/03/17/把《高性能MySQL》读薄/">把《高性能MySQL》读薄</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/15/使用Spring-Boot创建定时任务/">使用Spring Boot创建定时任务</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/05/SpringBoot配置HTTPS/">SpringBoot配置HTTPS</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/13/JVM的运行时数据区域、垃圾回收以及类加载机制/">JVM的运行时数据区域、垃圾回收以及类加载机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/20/SpringBoot-打包的时候报错-BeanCreationException/">SpringBoot 打包的时候报错 BeanCreationException</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/11/MySQL中索引的类型/">MySQL中索引的类型</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/07/MySQL数据库事务、隔离级别以及多版本并发控制-MVCC/">MySQL数据库事务、隔离级别以及多版本并发控制(MVCC)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/03/Spring-Boot中使用AOP输出接口请求参数与返回值/">Spring Boot中使用AOP输出接口请求参数与返回值</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/记录Ant-Design-Pro-Spring-Boot-jar包部署时遇到的坑/">记录Ant Design Pro+Spring Boot jar包部署时遇到的坑</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/01/分布式锁的认识/">分布式锁的认识</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">jiangwr.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>