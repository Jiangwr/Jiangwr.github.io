<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Redis中的数据结构与对象 | jiangweirong</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Redis中的数据结构与对象</h1><a id="logo" href="/.">jiangweirong</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Redis中的数据结构与对象</h1><div class="post-meta">Apr 5, 2021<span> | </span><span class="category"><a href="/categories/Redis/">Redis</a></span></div><div class="post-content"><p>&emsp;&emsp;Redis 中的每个键值对( key-value pair )都是由对象( object )组成的:</p>
<ul>
<li>数据库键永远都是一个字符串对象( string object )。</li>
<li>数据库键值可以是字符串对象( string object )、列表对象( list object )、哈希对象( hash object )、集合对象( set object )、有序集合对象( sorted set object )这五种对象中的其中一种。</li>
</ul>
<p>本篇主要介绍五个不同类型的对象，以及这些对象所使用的底层数据结构。</p>
<a id="more"></a>
<h1 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h1><p>&emsp;&emsp;Redis 把简单动态字符串( simple dynamic string, SDS )作为 Redis 的默认字符串表示。</p>
<p>&emsp;&emsp;在 Redis 中，C 字符串和简单动态字符串的使用场景如下:</p>
<ul>
<li>C 字符串只会作为字符串字面量( string literal ) 用在一些无需对字符串值进行修改的地方，比如打印日志:</li>
</ul>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redisLog(<span class="name">REDIS_WARNING</span>,<span class="string">"Redis is now ready to exit"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当 Redis 需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，Redis 就会使用 SDS 来表示字符串，比如在 Redis 数据库中，包含字符串值的键值对在底层实现都是由 SDS 实现的。</li>
<li>除了用来保存数据库中的字符串值之外，SDS 还被用作缓冲区( buffer ):AOF 模块中的 AOF 缓冲区，以及客户端状态中的输入缓冲区，都是由 SDS 实现的。</li>
</ul>
<h2 id="SDS-的定义"><a href="#SDS-的定义" class="headerlink" title="SDS 的定义"></a>SDS 的定义</h2><p>&emsp;&emsp;sds.h/sdshdr 的结构</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 记录 buf 数组中已使用的字节数量，等于 SDS 所保存的字符串长度。</span></span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">// 记录 buf 数组中未使用的字节数量。</span></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">// 字节数组，用来保存字符串</span></span><br><span class="line">	<span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/05/Redis中的数据结构与对象/SDS 示例.png" alt=""></p>
<p><strong>说明</strong>: SDS 遵循 C 字符串以空字符结尾的惯例，保存空字符的 1 字节空间不计算在 SDS 的 len 属性中，并且为空字符分配额外的 1 字节空间，以及添加空字符到字符串末尾等操作，都是由 SDS 函数自动完成的，所以这个空字符串对于 SDS 的使用者来说是完全透明的。<strong>遵循空字符结尾这一惯例的好处是</strong>，<strong>SDS 可以直接使用一部分 C 字符串函数库里的函数</strong>。</p>
<h2 id="SDS-与-C-字符串的区别"><a href="#SDS-与-C-字符串的区别" class="headerlink" title="SDS 与 C 字符串的区别"></a>SDS 与 C 字符串的区别</h2><p>&emsp;&emsp;Redis 为什么使用 SDS ？先放结论，因为 C 字符串无法满足 Redis 对字符串在安全性、效率以及功能方面的要求。</p>
<h3 id="常数时间复杂度获取字符串长度"><a href="#常数时间复杂度获取字符串长度" class="headerlink" title="常数时间复杂度获取字符串长度"></a>常数时间复杂度获取字符串长度</h3><p>&emsp;&emsp;因为 C 字符串不记录自身的长度信息，所以为了获取 C 字符串的长度，必须遍历整个字符串，这个操作的时间复杂度为 O(N)。对于 SDS 而言，因为 len 属性记录了 SDS 本身的长度，所以获取一个 SDS 长度的时间复杂度为 O(1)，设置和更新 SDS 长度的工作是由 SDS 的 API 在执行时自动完成的，使用 SDS 无须进行任何手动修改长度的操作。通过使用 SDS 而不是 C 字符串，Redis 将获取字符串长度的时间复杂度从 O(N) 降低到 O(1)。</p>
<h3 id="杜绝缓冲区溢出"><a href="#杜绝缓冲区溢出" class="headerlink" title="杜绝缓冲区溢出"></a>杜绝缓冲区溢出</h3><p>&emsp;&emsp;除了获取字符串长度的复杂度高以外，C 字符串不记录自身长度带来的另外一个问题时容易造成缓冲区溢出( buffer overflow )。</p>
<p>&emsp;&emsp;举个例子，<code>&lt;string.h&gt;/strcat</code> 函数可以将 src 字符串中的内容拼接到 dest 字符串的末尾:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;假设程序中有两个在内存中相邻的 C 字符串 s1 和 s2，如下图所示:</p>
<p><img src="/2021/04/05/Redis中的数据结构与对象/在内存中相邻的两个字符串.png" alt=""></p>
<p>当执行 <code>strcat(s1, &quot;Cluster&quot;)</code>  时</p>
<p><img src="/2021/04/05/Redis中的数据结构与对象/缓冲区溢出.png" alt=""></p>
<p>&emsp;&emsp;与 C 字符串不同，SDS 的空间分配策略杜绝发生缓冲区溢出的可能:当 SDS API 需要对 SDS 进行修改的时候，API 会先检查 SDS 的空间是否满足修改所需的要求，如果不满足，会进行扩容以满足所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区溢出的问题。</p>
<h3 id="减少修改字符串时所带来的内存重分配次数"><a href="#减少修改字符串时所带来的内存重分配次数" class="headerlink" title="减少修改字符串时所带来的内存重分配次数"></a>减少修改字符串时所带来的内存重分配次数</h3><p>&emsp;&emsp;由于 C 字符串不记录本身的长度，所以对于一个包含 N 个字符的 C 字符串来说，这个 C 字符串的底层实现总是 N + 1 个字符长的数组(额外一个字符空间用来保存空字符)，正因为 C 字符串的长度和底层数组的长度存在着这种关联，所以修改 C 字符串长度的时候，总要对保存 C 字符串的数组进行一次内存的重新分配操作:</p>
<ul>
<li>若是增长字符串的操作，程序需要通过内存重新分配来扩展底层数组的大小，避免发生缓冲区溢出。</li>
<li>若是缩短字符串的操作，程序需要通过内存重新分配来释放字符串不再使用的那部分空间，避免内存泄露。</li>
</ul>
<p>&emsp;&emsp;通过未使用空间，SDS 实现了空间预分配和惰性空间释放两种优化策略。</p>
<h4 id="空间预分配"><a href="#空间预分配" class="headerlink" title="空间预分配"></a><strong>空间预分配</strong></h4><p>&emsp;&emsp;当需要对 SDS 进行空间扩展的时候，程序不仅会为 SDS 分配修改所必须要的空间，还会为 SDS 分配额外的未使用空间。</p>
<p>&emsp;&emsp;额外分配的未使用空间大小由以下情况决定:</p>
<ul>
<li>若对 SDS 进行修改之后，SDS 的长度(即 len 的属性值) 小于 1MB，那么程序分配和 len 属性同样大小的未使用空间。</li>
<li>若对 SDS 进行修改之后，SDS 的长度大于等于 1MB，那么程序会分配 1MB 的使用空间内。</li>
</ul>
<p>&emsp;&emsp;通过空间预分配策略，Redis 可以减少连续执行字符串增长操作所需的内存重新分配次数。通过这种预分配策略，SDS 将连续增长 N 次的字符串所需的内存分配次数从必定 N 次降低为至多 N 次。</p>
<h4 id="惰性空间释放"><a href="#惰性空间释放" class="headerlink" title="惰性空间释放"></a><strong>惰性空间释放</strong></h4><p>&emsp;&emsp;惰性空间释放用于优化 SDS 的字符串缩短操作:当需要进行缩短的时候，程序不立即使用内存重新分配来回收多出来的空间，而是使用 free 属性将这些字节的数量记录下来，并等待将来使用。与此同时，SDS 也提供了 API，在有需要的时候，真正地释放 SDS 的未使用空间，所以不用担心惰性空间释放策略会造成内存浪费。</p>
<h3 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h3><p>&emsp;&emsp;C 字符串中的字符必须符合某种编码(比如 ASCII )，并且除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被读入的空字符会被认为是字符串结尾，这些限定使得 C 字符串值呢保存文本数据，而不能保存图片、音频、压缩文件这样的二进制数据。</p>
<p>&emsp;&emsp;SDS 的 API 都是二进制安全的( binary-safe ),所以 SDS API 都会以处理二进制的方式来处理 SDS 存放在 buf 数组中的数据，数据写入时是怎么样的，读取的时候就是什么。</p>
<p>&emsp;<strong>&emsp;这也是将 SDS 的 buf 属性称为字节数组的原因—Redis 不是用这个数组来保存字符的，而是用它来保存二进制数据</strong>。</p>
<h3 id="兼容部分-C-字符串函数"><a href="#兼容部分-C-字符串函数" class="headerlink" title="兼容部分 C 字符串函数"></a>兼容部分 C 字符串函数</h3><p>&emsp;&emsp;SDS 由于也是以空字符结尾，所以可以重用一部分 <code>&lt;string.h&gt;</code> 库中的函数，避免不必要的代码重复。 </p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>C 字符串和 SDS 的区别</strong></p>
<table>
<thead>
<tr>
<th>C 字符串</th>
<th>SDS</th>
</tr>
</thead>
<tbody>
<tr>
<td>获取字符串长度的时间复杂度为O(N)</td>
<td>获取字符串长度的时间复杂度为O(1)</td>
</tr>
<tr>
<td>API 不安全，可能会造成缓冲区溢出</td>
<td>API 安全，不会造成缓冲区溢出</td>
</tr>
<tr>
<td>修改字符串长度 N 次必然需要执行 N 次内存重新分配</td>
<td>修改字符串长度 N 次至多需要执行 N 次内存重新分配</td>
</tr>
<tr>
<td>只能保存文本数据</td>
<td>可以保存文本和二进制数据</td>
</tr>
<tr>
<td>可以使用<code>&lt;string.h&gt;</code>库中的所有函数</td>
<td>可以使用<code>&lt;string.h&gt;</code>库中的部分函数</td>
</tr>
</tbody>
</table>
<h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>《Redis 设计与实现》</li>
</ul>
</div><div class="tags"></div><div class="post-nav"><a class="next" href="/2021/02/04/union-find/">union find</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Scala/">Scala</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发经验/">开发经验</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构与算法/">数据结构与算法</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/04/05/Redis中的数据结构与对象/">Redis中的数据结构与对象</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/04/union-find/">union find</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/09/Rails响应请求的过程/">Rails 响应 Web 请求的过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/30/MacOS-10-15-安装-Rails-环境/">MacOS 10.15 安装 Rails 环境</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/10/Scala-中的尾递归/">Scala 中的尾递归</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/28/解决-MacOS-下-sbt-加载慢的问题/">解决 MacOS 下 sbt 加载慢的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/12/位运算的相关知识/">位运算的常见使用方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/19/大数据的基本认识/">大数据的简单认识</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/01/分布式锁的认识/">分布式锁的认识</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">jiangweirong</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>